#!/usr/bin/env python
# -*- coding: utf-8 -*-
#-------------------------------------------------------------------
# Filename: obspyck.py
#  Purpose: ...
#   Author: Tobias Megies, Lion Krischer
#    Email: megies@geophysik.uni-muenchen.de
#  License: GPLv2
#
# Copyright (C) 2010 Tobias Megies, Lion Krischer
#---------------------------------------------------------------------

import os
import sys
import shutil
import optparse
import warnings

from PyQt4 import QtGui, QtCore
from PyQt4.QtCore import QEvent, Qt
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.cm
import matplotlib.transforms
from matplotlib.patches import Ellipse
from matplotlib.ticker import FuncFormatter, FormatStrFormatter, MaxNLocator
from matplotlib.backends.backend_qt4agg import NavigationToolbar2QTAgg as QNavigationToolbar
from matplotlib.backend_bases import MouseEvent as MplMouseEvent, KeyEvent as MplKeyEvent
import lxml.etree
from lxml.etree import SubElement as Sub

#sys.path.append('/baysoft/obspy/misc/symlink')
#os.chdir("/baysoft/obspyck/")
from obspy.core import UTCDateTime
from obspy.signal.util import utlLonLat, utlGeoKm
from obspy.signal.invsim import estimateMagnitude
from obspy.imaging.spectrogram import spectrogram
from obspy.imaging.beachball import Beachball

from qt_designer import Ui_qMainWindow_obsPyck
from util import *


class ObsPyck(QtGui.QMainWindow):
    """
    Main Window with the design loaded from the Qt Designer.

    client, stream and options need to be determined by parsing the command
    line.
    """
    def __init__(self, client, streams, options, keys):
        """
        Standard init.
        """
        self.client = client
        self.streams = streams
        self.options = options
        self.keys = keys
        
        # init the GUI stuff
        QtGui.QMainWindow.__init__(self)
        # Init the widgets from the autogenerated file.
        # All GUI elements will be accessible via self.widgets.name_of_element
        self.widgets = Ui_qMainWindow_obsPyck()
        self.widgets.setupUi(self)

        # Create little color icons in front of the phase type combo box.
        # Needs to be done pretty much at the beginning because some other
        # stuff relies on the phase type being set.
        pixmap = QtGui.QPixmap(70, 50)
        for phase_type in list(SEISMIC_PHASES) + ['Mag']:
            rgb = matplotlib_color_to_rgb(PHASE_COLORS[phase_type])
            pixmap.fill(QtGui.QColor(*rgb))
            icon = QtGui.QIcon(pixmap)
            self.widgets.qComboBox_phaseType.addItem(icon, phase_type)

        self.qMain = self.widgets.centralwidget
        # Add write methods to stdout/stderr text edits in GUI displays to
        # enable redirections for stdout and stderr.
        # we need to remember the original handles because we only write on the
        # console during debug modus.
        self.stdout_backup = sys.stdout
        self.stderr_backup = sys.stderr
        # We automatically redirect all messages to both console and Gui boxes
        sys.stdout = SplitWriter(sys.stdout, self.widgets.qPlainTextEdit_stdout)
        sys.stderr = SplitWriter(sys.stderr, self.widgets.qPlainTextEdit_stderr)
        # Matplotlib figure.
        # we bind the figure to the FigureCanvas, so that it will be
        # drawn using the specific backend graphic functions
        self.canv = self.widgets.qMplCanvas
        # We have to reset all splitters such that the widget with the canvas
        # in it can not be collapsed as this leads to a crash of the program
        _i = self.widgets.qSplitter_vertical.indexOf(self.widgets.qSplitter_horizontal)
        self.widgets.qSplitter_vertical.setCollapsible(_i, False)
        _i = self.widgets.qSplitter_horizontal.indexOf(self.widgets.qWidget_mpl)
        self.widgets.qSplitter_horizontal.setCollapsible(_i, False)
        # XXX this resizing operation (buttons minimum size) should be done in
        # XXX the qt_designer.ui but I didn't find the correct settings there..
        self.widgets.qSplitter_horizontal.setSizes([1, 9999])
        # Bind the canvas to the mouse wheel event. Use Qt events for it
        # because the matplotlib events seem to have a problem with Debian.
        self.widgets.qMplCanvas.wheelEvent = self.__mpl_wheelEvent
        #self.keyPressEvent = self.__mpl_keyPressEvent

        self.fig = self.widgets.qMplCanvas.fig
        facecolor = self.qMain.palette().color(QtGui.QPalette.Window).getRgb()
        self.fig.set_facecolor([value / 255.0 for value in facecolor])

        #Define some flags, dictionaries and plotting options
        #this next flag indicates if we zoom on time or amplitude axis
        self.flagWheelZoomAmplitude = False
        check_keybinding_conflicts(KEYS)
        try:
            self.tmp_dir = setup_external_programs(options)
        except OSError:
            msg = "Cannot find external programs dir, localization " + \
                    "methods/functions are deactivated"
            warnings.warn(msg)
        self.dictOrigin = {}
        self.dictMagnitude = {}
        self.dictFocalMechanism = {} # currently selected focal mechanism
        self.focMechList = [] # list for all focal mechanisms from focmec
        # indicates which of the available focal mechanisms is selected
        self.focMechCurrent = None 
        # indicates how many focal mechanisms are available from focmec
        self.focMechCount = None
        self.dictEvent = {}
        self.spectrogramColormap = matplotlib.cm.jet
        # indicates which of the available events from seishub was loaded
        self.seishubEventCurrent = None 
        # indicates how many events are available from seishub
        self.seishubEventCount = None
        # save username of current user
        try:
            self.username = os.getlogin()
        except:
            try:
                self.username = os.environ['USER']
            except:
                self.username = "unknown"
        # setup server information
        self.server = {}
        server = self.server
        server['Server'] = "%s:%i" % (options.seishub_servername,
                                      options.seishub_port)
        server['BaseUrl'] = "http://" + server['Server']
        server['User'] = options.seishub_user # "obspyck"
        
        (warn_msg, merge_msg, streams) = \
                merge_check_and_cleanup_streams(streams, options)
        # if it's not empty show the merge info message now
        if merge_msg:
            print merge_msg
        # exit if no streams are left after removing everything not suited.
        if not streams:
            err = "No streams left to work with after removing bad streams."
            raise Exception(err)

        #XXX not used: self.dictsMap = {} #XXX not used yet!
        # set up dictionaries to store phase_type/axes/line informations
        self.lines = {}
        self.texts = {}

        # sort streams by station name
        streams.sort(key=lambda st: st[0].stats['station'])
        (streams, dicts) = setup_dicts(streams)
        self.dicts = dicts
        self.eventMapColors = []
        for i in xrange(len(dicts)):
            self.eventMapColors.append((0.,  1.,  0.,  1.))

        #Define a pointer to navigate through the streams
        self.stNum = len(streams)
        self.stPt = 0
        
        self.drawAxes()
        self.multicursor = MultiCursor(self.canv, self.axs, useblit=True,
                                       color='k', linewidth=1, ls='dotted')

        # Initialize the stream related widgets with the right values:
        self.widgets.qComboBox_streamName.clear()
        labels = ["%s.%s" % (st[0].stats.network, st[0].stats.station) \
                  for st in self.streams]
        self.widgets.qComboBox_streamName.addItems(labels)

        # set the filter default values according to command line options
        # or optionparser default values
        self.widgets.qDoubleSpinBox_highpass.setValue(self.options.highpass)
        self.widgets.qDoubleSpinBox_lowpass.setValue(self.options.lowpass)
        self.updateStreamLabels()

        print >> sys.stderr, warn_msg
        # Set up initial plot
        #fig = plt.figure()
        #fig.canvas.set_window_title("ObsPyck")
        #try:
        #    #not working with ion3 and other windowmanagers...
        #    fig.set_size_inches(20, 10, forward = True)
        #except:
        #    pass
        #redraw()
        #fig.canvas.draw()

        # XXX mpl connect XXX XXX XXX XXX XXX
        # XXX http://eli.thegreenplace.net/files/prog_code/qt_mpl_bars.py.txt
        # XXX http://eli.thegreenplace.net/2009/01/20/matplotlib-with-pyqt-guis/
        # XXX https://www.packtpub.com/sites/default/files/sample_chapters/7900-matplotlib-for-python-developers-sample-chapter-6-embedding-matplotlib-in-qt-4.pdf
        # XXX mpl connect XXX XXX XXX XXX XXX
        # Activate all mouse/key/Cursor-events
        # XXX MAYBE rename the event handles again so that they DONT get
        # XXX autoconnected via Qt?!?!?
        self.canv.mpl_connect('key_press_event', self.__mpl_keyPressEvent)
        self.canv.mpl_connect('key_release_event', self.__mpl_keyReleaseEvent)
        self.canv.mpl_connect('button_release_event', self.__mpl_mouseButtonReleaseEvent)
        # The scroll event is handled using Qt.
        #self.canv.mpl_connect('scroll_event', self.__mpl_wheelEvent)
        self.canv.mpl_connect('button_press_event', self.__mpl_mouseButtonPressEvent)
        self.canv.mpl_connect('motion_notify_event', self.__mpl_motionNotifyEvent)
        self.multicursorReinit()
        self.canv.show()
        self.showMaximized()
        # XXX XXX the good old focus issue again!?! no events get to the mpl canvas
        # XXX self.canv.setFocusPolicy(Qt.WheelFocus)
        #print self.canv.hasFocus()
        # XXX not working the way I want it to:
        #self.keyPressEvent = lambda ev: ev.key() == Qt.Key_Escape and self.emit(Qt.SIGNAL("escapePressed")) or QtGui.QMainWindow().keyPressEvent(ev)
        #self.event = lambda ev: (ev.type() == QtGui.QKeyEvent and ev.key() == Qt.Key_Escape) and self.__mpl_keyPressEvent(MplEvent("key_press_event", self.canv, guiEvent=ev)) or QtGui.QMainWindow().event(ev)

    
    # XXX
    #def eventFilter(self, obj, ev):
    #    print "no filtering but could..."
    #    return False

    #def event(self, ev):
    #    tmp = getattr(self, "tmp_ev", [])
    #    if not ev.type() in [77]:
    #        tmp.append(ev.type())
    #        self.tmp_ev = tmp
    #    if ev.type() == 51:
    #        return False
    #    if ev.type() == 99 or (ev.type() == QEvent.KeyPress and ev.key() == Qt.Key_Alt):
    #        "intercepted!"
    #        return False
    #        ev = KeyEvent("key_press_event", self.canv, "alt", x=10, y=10, guiEvent=ev)
    #        return self.keyPressEvent(ev)
    #    return QtGui.QMainWindow.event(self, ev)
        
    #def event(self, ev):
    #    """
    #    Event handling. We override some keys with special behavior to just
    #    emit the standard push-the-button signal.
    #    """
    #    #if ev.type() == QEvent.KeyPress:
    #    #    if ev.key() == Qt.Key_Alt:
    #    #        print "overriding"
    #    #        from matplotlib.backend_bases import KeyEvent
    #    #        e = KeyEvent("key_press_event", self.canv, "alt", x=0, y=0, guiEvent=ev)
    #    #        self.__mpl_keyPressEvent(e)
    #    #        #self.emit(QtCore.SIGNAL("altPressed"))
    #    #        return True
    #    #        print "bad"
    #    if ev.type() == QEvent.Wheel:
    #        # Mapping from Qt MainWindow coordinates to mpl Canvas coordinates
    #        # Qt: Starting at top left window corner, y positive down
    #        # Mpl: Starting at bottom left canvas corner, y positive up
    #        #
    #        #         ev.x()   ----->
    #        #     ------------------------------------------------------
    #        # ev.y()                                                   |
    #        #  |  |     self.canv.pos()                                |
    #        #  |  |                 X-------------------------         |
    #        #  v  |                 |                      ^ |         |
    #        #     |                 |    self.canv.height()| |         |
    #        #     |                 |                      | |         |
    #        #     |                 |   self.canv.width()  | |         |
    #        #     |                 |<---------------------+>|         |
    #        #     |               ^ |                      | |         |
    #        #     |               | |                      | |         |
    #        #     |               | |                      v |         |
    #        #     |            e.y()--------------------------         |
    #        #     |                  e.x() --->                        |
    #        #     |                                                    |
    #        #     ------------------------------------------------------
    #        x = ev.x() - self.canv.pos().x()
    #        y = self.canv.pos().y() + self.canv.height() - ev.y()
    #        # only override if in mpl canvas XXX not exactly correct!?!!!
    #        if x < 0 or x > self.canv.height() or y < 0 or y > self.canv.width():
    #            print "overriding canceled (not in canvas)!!"
    #            return QtGui.QMainWindow.event(self, ev)
    #        print "overriding!!"
    #        if ev.delta() > 0:
    #            button = "up"
    #        else:
    #            button = "down"
    #        e = MplMouseEvent("scroll_event", self.canv, x, y, button, guiEvent=ev)
    #        self.__mpl_wheelEvent(e)
    #        return True
    #    return QtGui.QMainWindow.event(self, ev)
    
    def cleanup(self):
        """
        Cleanup and prepare for quit.
        Do:
            - check if sysop duplicates are there
            - remove temporary directory and all contents
        """
        if self.client:
            self.checkForSysopEventDuplicates(self.streams[0][0].stats.starttime,
                                              self.streams[0][0].stats.endtime)
        try:
            shutil.rmtree(self.tmp_dir)
        except:
            pass

    ###########################################################################
    ### signal handlers START #################################################
    ###########################################################################

    def on_qToolButton_overview_toggled(self):
        state = self.widgets.qToolButton_overview.isChecked()
        widgets_leave_active = ("qToolButton_overview",
                                "qPlainTextEdit_stdout",
                                "qPlainTextEdit_stderr")
        for name in WIDGET_NAMES:
            if name not in widgets_leave_active:
                widget = getattr(self.widgets, name)
                widget.setEnabled(not state)
        if state:
            self.delAxes()
            self.fig.clear()
            self.drawStreamOverview()
            self.multicursor.visible = False
            self.canv.draw()
        else:
            self.delAxes()
            self.fig.clear()
            self.drawAxes()
            self.drawAllItems()
            self.multicursorReinit()
            self.updatePlot()
            self.updateStreamLabels()
            self.canv.draw()

    def on_qToolButton_clearAll_clicked(self, *args):
        # Workaround for overloaded signals:
        #  - "clicked" signal get emitted once without *args and once with an
        #    int as additional argument
        #  - we have to be flexible in the call, otherwise we get errors
        #  - we have to catch one signal, otherwise the action gets performed
        #    twice
        if args:
            return
        self.clearDictionaries()
        self.updateAllItems()
        self.redraw()

    def on_qToolButton_clearOrigMag_clicked(self, *args):
        if args:
            return
        self.clearOriginMagnitudeDictionaries()
        self.updateAllItems()
        self.redraw()

    def on_qToolButton_clearFocMec_clicked(self, *args):
        if args:
            return
        self.clearFocmecDictionary()

    def on_qToolButton_doHyp2000_clicked(self, *args):
        if args:
            return
        self.delAllItems()
        self.clearOriginMagnitudeDictionaries()
        self.dictOrigin['Program'] = "hyp2000"
        self.doHyp2000()
        self.loadHyp2000Data()
        self.calculateEpiHypoDists()
        self.dictMagnitude['Program'] = "obspy"
        self.calculateStationMagnitudes()
        self.updateNetworkMag()
        self.drawAllItems()
        self.redraw()
        self.widgets.qToolButton_showMap.setChecked(True)

    def on_qToolButton_do3dloc_clicked(self, *args):
        if args:
            return
        self.delAllItems()
        self.clearOriginMagnitudeDictionaries()
        self.dictOrigin['Program'] = "3dloc"
        self.do3dLoc()
        self.load3dlocSyntheticPhases()
        self.load3dlocData()
        self.calculateEpiHypoDists()
        self.dictMagnitude['Program'] = "obspy"
        self.calculateStationMagnitudes()
        self.updateNetworkMag()
        self.drawAllItems()
        self.redraw()
        self.widgets.qToolButton_showMap.setChecked(True)

    def on_qToolButton_doNlloc_clicked(self, *args):
        if args:
            return
        self.delAllItems()
        self.clearOriginMagnitudeDictionaries()
        self.dictOrigin['Program'] = "NLLoc"
        self.doNLLoc()
        self.loadNLLocOutput()
        self.calculateEpiHypoDists()
        self.dictMagnitude['Program'] = "obspy"
        self.calculateStationMagnitudes()
        self.updateNetworkMag()
        self.drawAllItems()
        self.redraw()
        self.widgets.qToolButton_showMap.setChecked(True)

    def on_qToolButton_calcMag_clicked(self, *args):
        if args:
            return
        self.calculateEpiHypoDists()
        self.dictMagnitude['Program'] = "obspy"
        self.calculateStationMagnitudes()
        self.updateNetworkMag()

    def on_qToolButton_doFocMec_clicked(self, *args):
        if args:
            return
        self.clearFocmecDictionary()
        self.dictFocalMechanism['Program'] = "focmec"
        self.doFocmec()

    def on_qToolButton_showMap_toggled(self):
        state = self.widgets.qToolButton_showMap.isChecked()
        widgets_leave_active = ("qToolButton_showMap",
                                "qPlainTextEdit_stdout",
                                "qPlainTextEdit_stderr")
        for name in WIDGET_NAMES:
            if name not in widgets_leave_active:
                widget = getattr(self.widgets, name)
                widget.setEnabled(not state)
        # XXX XXX would be better to avoid list of widget names nd do it
        # XXX XXX dynamically, but it doesnt work..
        # XXX tmp = (getattr(self.widgets, name) for name in widgets_leave_active)
        # XXX for widget in self.children():
        # XXX     print "%s\n" % widget.objectName()
        # XXX     widget.setEnabled(not state)
        # XXX for widget in tmp:
        # XXX     widget.setEnabled(state)
        if state:
            self.delAxes()
            self.fig.clear()
            self.drawEventMap()
            self.multicursor.visible = False
            self.canv.draw()
            #print "http://maps.google.de/maps?f=q&q=%.6f,%.6f" % \
            #       (self.dictOrigin['Latitude'], self.dictOrigin['Longitude'])
            link = "http://maps.google.de/maps?f=q&q=%.6f,%.6f" % \
                    (self.dictOrigin['Latitude'], self.dictOrigin['Longitude'])
            self.widgets.qPlainTextEdit_stdout.appendHtml("<a href='%s'>%s</a> &nbsp;" % (link, link))
        else:
            self.delEventMap()
            self.fig.clear()
            self.drawAxes()
            self.drawAllItems()
            self.multicursorReinit()
            self.updatePlot()
            self.updateStreamLabels()
            self.canv.draw()

    def on_qToolButton_showFocMec_toggled(self):
        state = self.widgets.qToolButton_showFocMec.isChecked()
        widgets_leave_active = ("qToolButton_showFocMec",
                                "qToolButton_nextFocMec",
                                "qPlainTextEdit_stdout",
                                "qPlainTextEdit_stderr")
        for name in WIDGET_NAMES:
            if name not in widgets_leave_active:
                widget = getattr(self.widgets, name)
                widget.setEnabled(not state)
        if state:
            self.delAxes()
            self.fig.clear()
            self.drawFocMec()
            self.multicursor.visible = False
            self.canv.draw()
        else:
            self.delFocMec()
            self.fig.clear()
            self.drawAxes()
            self.drawAllItems()
            self.multicursorReinit()
            self.updatePlot()
            self.updateStreamLabels()
            self.canv.draw()

    def on_qToolButton_nextFocMec_clicked(self, *args):
        if args:
            return
        self.nextFocMec()
        if self.widgets.qToolButton_showFocMec.isChecked():
            self.delFocMec()
            self.fig.clear()
            self.drawFocMec()
            self.canv.draw()

    def on_qToolButton_showWadati_toggled(self):
        state = self.widgets.qToolButton_showWadati.isChecked()
        widgets_leave_active = ("qToolButton_showWadati",
                                "qPlainTextEdit_stdout",
                                "qPlainTextEdit_stderr")
        for name in WIDGET_NAMES:
            if name not in widgets_leave_active:
                widget = getattr(self.widgets, name)
                widget.setEnabled(not state)
        if state:
            self.delAxes()
            self.fig.clear()
            self.drawWadati()
            self.multicursor.visible = False
            self.canv.draw()
        else:
            self.delWadati()
            self.fig.clear()
            self.drawAxes()
            self.drawAllItems()
            self.multicursorReinit()
            self.updatePlot()
            self.updateStreamLabels()
            self.canv.draw()

    def on_qToolButton_getNextEvent_clicked(self, *args):
        if args:
            return
        # check if event list is empty and force an update if this is the case
        if not hasattr(self, "seishubEventList"):
            self.updateEventListFromSeishub(self.streams[0][0].stats.starttime,
                                            self.streams[0][0].stats.endtime)
        if not self.seishubEventList:
            print "No events available from SeisHub."
            return
        # iterate event number to fetch
        self.seishubEventCurrent = (self.seishubEventCurrent + 1) % \
                                   self.seishubEventCount
        event = self.seishubEventList[self.seishubEventCurrent]
        resource_name = event.get('resource_name')
        self.clearDictionaries()
        self.getEventFromSeishub(resource_name)
        self.updateAllItems()
        self.redraw()
        
    def on_qToolButton_updateEventList_clicked(self, *args):
        if args:
            return
        self.updateEventListFromSeishub(self.streams[0][0].stats.starttime,
                                        self.streams[0][0].stats.endtime)

    def on_qToolButton_sendEvent_clicked(self, *args):
        if args:
            return
        self.uploadSeishub()
        self.checkForSysopEventDuplicates(self.streams[0][0].stats.starttime,
                                          self.streams[0][0].stats.endtime)

    def on_qCheckBox_publishEvent_toggled(self):
        newstate = self.widgets.qCheckBox_publishEvent.isChecked()
        print "Setting \"public\" flag of event to: %s" % newstate

    def on_qToolButton_deleteEvent_clicked(self, *args):
        if args:
            return
        event = self.seishubEventList[self.seishubEventCurrent]
        resource_name = event.get('resource_name')
        account = event.get('account')
        user = event.get('user')
        qMessageBox = QtGui.QMessageBox()
        qMessageBox.setWindowIcon(QtGui.QIcon(QtGui.QPixmap("obspyck.gif")))
        qMessageBox.setIcon(QtGui.QMessageBox.Warning)
        qMessageBox.setWindowTitle("Delete?")
        qMessageBox.setText("Delete event from database?")
        msg = "%s  (account: %s, user: %s)" % (resource_name, account, user)
        qMessageBox.setInformativeText(msg)
        qMessageBox.setStandardButtons(QtGui.QMessageBox.Cancel | QtGui.QMessageBox.Ok)
        qMessageBox.setDefaultButton(QtGui.QMessageBox.Cancel)
        if qMessageBox.exec_() == QtGui.QMessageBox.Ok:
            self.deleteEventInSeishub(resource_name)
            self.on_qToolButton_updateEventList_clicked(event)
    
    def on_qCheckBox_sysop_toggled(self):
        newstate = self.widgets.qCheckBox_sysop.isChecked()
        if not str(self.widgets.qLineEdit_sysopPassword.text()):
            self.widgets.qCheckBox_sysop.setChecked(False)
            err = "Error: Enter password for \"sysop\"-account first."
            print >> sys.stderr, err
        else:
            print "Setting usage of \"sysop\"-account to: %s" % newstate
    
    # the corresponding signal is emitted when hitting return after entering
    # the password
    def on_qLineEdit_sysopPassword_editingFinished(self):
        passwd = str(self.widgets.qLineEdit_sysopPassword.text())
        tmp_client = Client(base_url=self.server['BaseUrl'], user="sysop",
                            password=passwd)
        if tmp_client.testAuth():
            self.client_sysop = tmp_client
            self.widgets.qCheckBox_sysop.setChecked(True)
        # if authentication test fails empty password field and uncheck sysop
        else:
            self.client_sysop = None
            self.widgets.qCheckBox_sysop.setChecked(False)
            self.widgets.qLineEdit_sysopPassword.clear()
            err = "Error: Authentication as sysop failed! (Wrong password!?)"
            print >> sys.stderr, err
        self.canv.setFocus() # XXX needed??
    # XXX XXX not used atm. relict from gtk when buttons snatch to grab the
    # XXX XXX focus away from the mpl-canvas to which key/mouseButtonPresses are
    # XXX XXX connected
    # XXX def on_buttonSetFocusOnPlot_clicked(self, event):
    # XXX     self.setFocusToMatplotlib()

    def on_qToolButton_debug_clicked(self, *args):
        if args:
            return
        self.debug()
    
    def on_qToolButton_previousStream_clicked(self, *args):
        if args:
            return
        self.stPt = (self.stPt - 1) % self.stNum
        self.widgets.qComboBox_streamName.setCurrentIndex(self.stPt)

    def on_qComboBox_streamName_currentIndexChanged(self, newvalue):
        self.stPt = self.widgets.qComboBox_streamName.currentIndex()
        xmin, xmax = self.axs[0].get_xlim()
        self.delAllItems()
        self.delAxes()
        self.fig.clear()
        self.drawAxes()
        self.drawAllItems()
        self.multicursorReinit()
        self.axs[0].set_xlim(xmin, xmax)
        self.updatePlot()
        stats = self.streams[self.stPt][0].stats
        print "Going to stream: %s.%s" % (stats.network, stats.station)
        self.updateStreamNumberLabel()

    def on_qToolButton_nextStream_clicked(self, *args):
        if args:
            return
        self.stPt = (self.stPt + 1) % self.stNum
        self.widgets.qComboBox_streamName.setCurrentIndex(self.stPt)

    def on_qComboBox_phaseType_currentIndexChanged(self, newvalue):
        # XXX: Ugly hack because it can be called before the combo box has any
        # entries.
        try:
            self.updateMulticursorColor()
            self.redraw()
        except AttributeError:
            pass

    def on_qToolButton_filter_toggled(self):
        self.updatePlot()

    def on_qComboBox_filterType_currentIndexChanged(self, newvalue):
        if self.widgets.qToolButton_filter.isChecked():
            self.updatePlot()

    def on_qCheckBox_zerophase_toggled(self):
        if self.widgets.qToolButton_filter.isChecked():
            self.updatePlot()

    def on_qDoubleSpinBox_highpass_valueChanged(self, newvalue):
        widgets = self.widgets
        stats = self.streams[self.stPt][0].stats
        if not widgets.qToolButton_filter.isChecked() or \
           str(widgets.qComboBox_filterType.currentText()) == "Lowpass":
            self.canv.setFocus() # XXX needed??
            return
        # if the filter flag is not set, we don't have to update the plot
        # XXX if we have a lowpass, we dont need to update!! Not yet implemented!! XXX
        if widgets.qDoubleSpinBox_lowpass.value() < newvalue:
            err = "Warning: Lowpass frequency below Highpass frequency!"
            print >> sys.stderr, err
        # XXX maybe the following check could be done nicer
        # XXX check this criterion!
        minimum  = float(stats.sampling_rate) / stats.npts
        if newvalue < minimum:
            err = "Warning: Lowpass frequency is not supported by length of trace!"
            print >> sys.stderr, err
        self.updatePlot()
        # XXX we could use this for the combobox too!
        # reset focus to matplotlib figure
        self.canv.setFocus() # XXX needed?? # XXX do we still need this focus grabbing with QT??? XXX XXX XXX XXX

    def on_qDoubleSpinBox_lowpass_valueChanged(self, newvalue):
        widgets = self.widgets
        stats = self.streams[self.stPt][0].stats
        if not widgets.qToolButton_filter.isChecked() or \
           str(widgets.qComboBox_filterType.currentText()) == "Highpass":
            self.canv.setFocus() # XXX needed??
            return
        # if the filter flag is not set, we don't have to update the plot
        # XXX if we have a highpass, we dont need to update!! Not yet implemented!! XXX
        if newvalue < widgets.qDoubleSpinBox_highpass.value():
            err = "Warning: Lowpass frequency below Highpass frequency!"
            print >> sys.stderr, err
        # XXX maybe the following check could be done nicer
        # XXX check this criterion!
        maximum  = stats.sampling_rate / 2.0 # Nyquist
        if newvalue > maximum:
            err = "Warning: Highpass frequency is lower than Nyquist!"
            print >> sys.stderr, err
        self.updatePlot()
        # XXX we could use this for the combobox too!
        # reset focus to matplotlib figure
        self.canv.setFocus() # XXX needed??

    def on_qToolButton_spectrogram_toggled(self):
        state = self.widgets.qToolButton_spectrogram.isChecked()
        widgets_deactivate = ("qToolButton_filter", "qToolButton_overview",
                "qComboBox_filterType", "qCheckBox_zerophase",
                "qLabel_highpass", "qLabel_lowpass", "qDoubleSpinBox_highpass",
                "qDoubleSpinBox_lowpass")
        for name in widgets_deactivate:
            widget = getattr(self.widgets, name)
            widget.setEnabled(not state)
        if state:
            msg = "Showing spectrograms (takes a few seconds with log-option)."
        else:
            msg = "Showing seismograms."
        print msg
        xmin, xmax = self.axs[0].get_xlim()
        self.delAllItems()
        self.delAxes()
        self.fig.clear()
        self.drawAxes()
        self.drawAllItems()
        self.multicursorReinit()
        self.axs[0].set_xlim(xmin, xmax)
        self.updatePlot()

    def on_qCheckBox_spectrogramLog_toggled(self):
        if self.widgets.qToolButton_spectrogram.isChecked():
            self.on_qToolButton_spectrogram_toggled()

    ###########################################################################
    ### signal handlers END ###### ############################################
    ###########################################################################

    def _filter(self, stream):
        """
        Applies filter currently selected in GUI to Trace or Stream object.
        Also displays a message.
        """
        w = self.widgets
        type = str(w.qComboBox_filterType.currentText()).lower()
        options = {}
        options['corners'] = 1
        options['zerophase'] = w.qCheckBox_zerophase.isChecked()
        if type in ("bandpass", "bandstop"):
            options['freqmin'] = w.qDoubleSpinBox_highpass.value()
            options['freqmax'] = w.qDoubleSpinBox_lowpass.value()
        elif type == "lowpass":
            options['freq'] = w.qDoubleSpinBox_lowpass.value()
        elif type == "highpass":
            options['freq'] = w.qDoubleSpinBox_highpass.value()
        if type in ("bandpass", "bandstop"):
            msg = "%s (zerophase=%s): %.2f-%.2f Hz" % \
                    (type, options['zerophase'],
                     options['freqmin'], options['freqmax'])
        elif type in ("lowpass", "highpass"):
            msg = "%s (zerophase=%s): %.2f Hz" % \
                    (type, options['zerophase'], options['freq'])
        try:
            stream.filter(type, options)
            print msg
        except:
            err = "Error during filtering. Showing unfiltered data."
            print >> sys.stderr, err

    def debug(self):
        sys.stdout = self.stdout_backup
        sys.stderr = self.stderr_backup
        ## DEBUG PYQT START
        QtCore.pyqtRemoveInputHook()
        try:
            import ipdb
            ipdb.set_trace()
        except ImportError:
            import pdb
            pdb.set_trace()
        QtCore.pyqtRestoreInputHook()
        ## DEBUG PYQT END
        self.stdout_backup = sys.stdout
        self.stderr_backup = sys.stderr
        sys.stdout = SplitWriter(sys.stdout, self.widgets.qPlainTextEdit_stdout)
        sys.stderr = SplitWriter(sys.stderr, self.widgets.qPlainTextEdit_stderr)

    def setFocusToMatplotlib(self):
        self.canv.setFocus() # XXX needed??

    def drawLine(self, key):
        """
        Draw a line for pick of given key in all axes of the current stream.
        Stores the line in a dict to be able to remove the line later on.

        self.Lines contains dict for each phase type (e.g. "P").
        self.Lines[phase_type] is a dict mapping axes objects to line objects.
        e.g.: self.Lines["P"][<matplotlib.axes.AxesSubplot object at 0x...>]
              would return the line object for the P phase in the given axes.
        """
        if key in self.lines:
            self.delLine(key)
        d = self.dicts[self.stPt]
        if key not in d:
            return
        self.lines[key] = {}
        ymin = 1.0 - PHASE_LINEHEIGHT_PERC[key]
        ymax = PHASE_LINEHEIGHT_PERC[key]
        # draw lines and store references in dictionary
        for ax in self.axs:
            line = ax.axvline(d[key], color=PHASE_COLORS[key],
                    linewidth=AXVLINEWIDTH, linestyle=PHASE_LINESTYLES[key],
                    ymin=ymin, ymax=ymax)
            self.lines[key][ax] = line
    
    def delLine(self, key):
        """
        Delete all lines for pick of given key in all axes of the current
        stream.
        
        See drawLine().
        """
        if key not in self.lines:
            return
        for ax, line in self.lines[key].iteritems():
            ax.lines.remove(line)
        del self.lines[key]

    def updateLine(self, key):
        self.delLine(key)
        self.drawLine(key)
    
    def drawLabel(self, key):
        """
        Draws Labels at pick axvlines.
        Currently expects as keys either "P" or "S".
        """
        # delegate drawing of synthetic picks, this is different...
        if 'synth' in key:
            return self.drawSynthLabel(key)
        dict = self.dicts[self.stPt]
        if key not in dict:
            return
        label = key + ':'
        # try to recognize and map the onset string to a character
        key_onset = key + 'Onset'
        if key_onset in dict:
            label += ONSET_CHARS.get(dict[key_onset].lower(), "?")
        else:
            label += '_'
        # try to recognize and map the polarity string to a character
        key_pol = key + 'Pol'
        if key_pol in dict:
            label += POLARITY_CHARS.get(dict[key_pol].lower(), "?")
        else:
            label += '_'
        key_weight = key + 'Weight'
        if key_weight in dict:
            label += str(dict[key_weight])
        else:
            label += '_'
        ax = self.axs[0]
        # draw text and store references in dictionary
        self.texts[key] = {}
        text = ax.text(dict[key], 1 - 0.01 * len(self.axs), '  ' + label,
                transform=self.trans[0], color=PHASE_COLORS[key],
                family='monospace', va="top")
        self.texts[key][ax] = text

    def drawSynthLabel(self, key):
        """
        Draw the label for a synthetic pick. This is a bit different from
        the other labels.
        """
        dict = self.dicts[self.stPt]
        if key not in dict:
            return
        key_res = key[0] + "res"
        label = '%s: %+.3fs' % (key, dict[key_res])
        ax = self.axs[0]
        # draw text and store references in dictionary
        self.texts[key] = {}
        text = ax.text(dict[key], 1 - 0.03 * len(self.axs), '  ' + label,
                transform=self.trans[0], color=PHASE_COLORS[key],
                family='monospace', va="top")
        self.texts[key][ax] = text
    
    def delLabel(self, key):
        """
        Delete label for pick of given key in the current stream.
        
        See drawLabel().
        """
        if key not in self.texts:
            return
        for ax, text in self.texts[key].iteritems():
            ax.texts.remove(text)
        del self.texts[key]

    def updateLabel(self, key):
        self.delLabel(key)
        self.drawLabel(key)

    def drawMagMarker(self, key):
        """
        Draw a magnitude marker for pick of given key in the current stream.
        Stores the line in a dict to be able to remove the line later on.
        See drawLine() for details.

        Currently we expect either MagMin1, MagMax1, MagMin2 or MagMax2 so
        we estimate the axes we plot into by the last character of the key.
        Furthermore, we expect another key to exist that is key+"T" (e.g.
        MagMin1T for MagMin1) with the time information.
        """
        if key in self.lines:
            self.delLine(key)
        d = self.dicts[self.stPt]
        if key not in d: # or len(self.axs) < 2
            return
        ax_num = int(key[-1])
        ax = self.axs[ax_num]
        # we have to force the graph to the old axes limits because of the
        # completely new line object creation
        xlims = list(ax.get_xlim())
        ylims = list(ax.get_ylim())
        keyT = key + "T"
        self.lines[key] = {}
        line = ax.plot((d[keyT],), (d[key],), markersize=MAG_MARKER['size'],
                markeredgewidth=MAG_MARKER['edgewidth'],
                color=PHASE_COLORS['Mag'], marker=MAG_MARKER['marker'],
                zorder=2000)[0]
        self.lines[key][ax] = line
        ax.set_xlim(xlims)
        ax.set_ylim(ylims)

    def delMagMarker(self, key):
        self.delLine(key)
    
    def updateMagMarker(self, key):
        self.delMagMarker(key)
        self.drawMagMarker(key)
    
    def delKey(self, key):
        dict = self.dicts[self.stPt]
        if key not in dict:
            return
        del dict[key]
        print "%s deleted." % KEY_FULLNAMES[key]
        # we have to take care of some special cases:
        if key == 'S':
            if 'Saxind' in dict:
                del dict['Saxind']
        elif key in ['MagMin1', 'MagMax1', 'MagMin2', 'MagMax2']:
            key2 = key + 'T'
            del dict[key2]
    
    def drawAxes(self):
        st = self.streams[self.stPt]
        #we start all our x-axes at 0 with the starttime of the first (Z) trace
        starttime_global = st[0].stats.starttime
        fig = self.fig
        axs = []
        self.axs = axs
        plts = []
        self.plts = plts
        trans = []
        self.trans = trans
        t = []
        self.t = t
        for i, tr in enumerate(st):
            if i == 0:
                ax = fig.add_subplot(len(st), 1, 1)
            else:
                ax = fig.add_subplot(len(st), 1, i+1, sharex=axs[0], sharey=axs[0])
                ax.xaxis.set_ticks_position("top")
            axs.append(ax) 
            #make sure that the relative times of the x-axes get mapped to our
            #global stream (absolute) starttime (starttime of first (Z) trace)
            starttime_local = tr.stats.starttime - starttime_global
            dt = 1. / tr.stats.sampling_rate
            sampletimes = np.arange(starttime_local,
                    starttime_local + (dt * tr.stats.npts), dt)
            # XXX sometimes our arange is one item too long (why??), so we just cut
            # off the last item if this is the case
            if len(sampletimes) == tr.stats.npts + 1:
                sampletimes = sampletimes[:-1]
            t.append(sampletimes)
            trans.append(matplotlib.transforms.blended_transform_factory(ax.transData,
                                                                         ax.transAxes))
            ax.xaxis.set_major_formatter(FuncFormatter(formatXTicklabels))
            if self.widgets.qToolButton_spectrogram.isChecked():
                log = self.widgets.qCheckBox_spectrogramLog.isChecked()
                spectrogram(tr.data, tr.stats.sampling_rate, log=log,
                            cmap=self.spectrogramColormap, axis=ax, zorder=-10)
                textcolor = "red"
            else:
                # normalize with overall sensitivity and convert to nm/s
                # if not explicitly deactivated on command line
                if not self.options.nonormalization:
                    plts.append(ax.plot(sampletimes, tr.data / tr.stats.paz.sensitivity * 1e9, color='k', zorder=1000)[0])
                else:
                    plts.append(ax.plot(sampletimes, tr.data, color='k', zorder=1000)[0])
                textcolor = "blue"
            tr_id = "%s.%s.%s.%s" % (tr.stats.network, tr.stats.station, tr.stats.location, tr.stats.channel)
            ax.text(0.01, 0.95, tr_id, va="top", ha="left", fontsize=18,
                    family='monospace', color=textcolor, zorder=10000,
                    transform=ax.transAxes)
        axs[-1].xaxis.set_ticks_position("both")
        self.supTit = fig.suptitle("%s.%03d -- %s.%03d" % (st[0].stats.starttime.strftime("%Y-%m-%d  %H:%M:%S"),
                                                         st[0].stats.starttime.microsecond / 1e3 + 0.5,
                                                         st[0].stats.endtime.strftime("%H:%M:%S"),
                                                         st[0].stats.endtime.microsecond / 1e3 + 0.5), ha="left", va="bottom", x=0.01, y=0.01)
        self.xMin, self.xMax = axs[0].get_xlim()
        self.yMin, self.yMax = axs[0].get_ylim()
        fig.subplots_adjust(bottom=0.001, hspace=0.000, right=0.999, top=0.999, left=0.001)
    
    def delAxes(self):
        for ax in self.axs:
            if ax in self.fig.axes: 
                self.fig.delaxes(ax)
            del ax
        if self.supTit in self.fig.texts:
            self.fig.texts.remove(self.supTit)
    
    def redraw(self):
        for line in self.multicursor.lines:
            line.set_visible(False)
        self.canv.draw()
    
    def updatePlot(self):
        """
        Update plot either with raw data or filter data and use filtered data.
        Depending on status of "Filter" Button.
        """
        st = self.streams[self.stPt]
        # To display filtered data we overwrite our alias to current stream
        # and replace it with the filtered data.
        if self.widgets.qToolButton_filter.isChecked():
            st = st.copy()
            self._filter(st)
        else:
            print "Unfiltered Traces."
        # Update all plots' y data
        for tr, plot in zip(st, self.plts):
            plot.set_ydata(tr.data)
        self.redraw()

    # Define the event that handles the setting of P- and S-wave picks
    # XXX prefix with underscores to avoid autoconnect to Qt
    def __mpl_keyPressEvent(self, ev):
        if self.widgets.qToolButton_showMap.isChecked():
            return
        keys = self.keys
        phase_type = str(self.widgets.qComboBox_phaseType.currentText())
        dict = self.dicts[self.stPt]
        st = self.streams[self.stPt]
        
        #######################################################################
        # Start of key events related to picking                              #
        #######################################################################
        # For some key events (picking events) we need information on the x/y
        # position of the cursor:
        if ev.key in [keys['setPick'], keys['setPickError'],
                      keys['setMagMin'], keys['setMagMax']]:
            # some keyPress events only make sense inside our matplotlib axes
            if ev.inaxes not in self.axs:
                return
            #We want to round from the picking location to
            #the time value of the nearest time sample:
            samp_rate = st[0].stats.sampling_rate
            pickSample = ev.xdata * samp_rate
            pickSample = round(pickSample)
            pickSample = pickSample / samp_rate
            # we need the position of the cursor location
            # in the seismogram array:
            xpos = pickSample * samp_rate

        if ev.key == keys['setPick']:
            # some keyPress events only make sense inside our matplotlib axes
            if not ev.inaxes in self.axs:
                return
            if phase_type in SEISMIC_PHASES:
                dict[phase_type] = pickSample
                if phase_type == "S":
                    dict['Saxind'] = self.axs.index(ev.inaxes)
                depending_keys = (phase_type + k for k in ['', 'synth'])
                for key in depending_keys:
                    self.updateLine(key)
                    self.updateLabel(key)
                #check if the new P pick lies outside of the Error Picks
                key1 = phase_type + "Err1"
                key2 = phase_type + "Err2"
                if key1 in dict and dict[phase_type] < dict[key1]:
                    self.delLine(key1)
                    self.delKey(key1)
                if key2 in dict and dict[phase_type] > dict[key2]:
                    self.delLine(key2)
                    self.delKey(key2)
                self.redraw()
                abs_time = st[0].stats.starttime + dict[phase_type]
                print "%s set at %.3f (%s)" % (KEY_FULLNAMES[phase_type],
                                               dict[phase_type], abs_time.isoformat())
                return

        if ev.key in keys['setWeight'].keys():
            if phase_type in SEISMIC_PHASES:
                if phase_type not in dict:
                    return
                key = phase_type + "Weight"
                dict[key] = keys['setWeight'][ev.key]
                self.updateLabel(phase_type)
                self.redraw()
                print "%s set to %i" % (KEY_FULLNAMES[key], dict[key])
                return

        if ev.key in keys['setPol'].keys():
            if phase_type in SEISMIC_PHASES:
                if phase_type not in dict:
                    return
                key = phase_type + "Pol"
                dict[key] = keys['setPol'][ev.key]
                self.updateLabel(phase_type)
                self.redraw()
                print "%s set to %s" % (KEY_FULLNAMES[key], dict[key])
                return

        if ev.key in keys['setOnset'].keys():
            if phase_type in SEISMIC_PHASES:
                if phase_type not in dict:
                    return
                key = phase_type + "Onset"
                dict[key] = keys['setOnset'][ev.key]
                self.updateLabel(phase_type)
                self.redraw()
                print "%s set to %s" % (KEY_FULLNAMES[key], dict[key])
                return

        if ev.key == keys['delPick']:
            if phase_type in SEISMIC_PHASES:
                depending_keys = (phase_type + k for k in ['', 'Err1', 'Err2'])
                for key in depending_keys:
                    self.delLine(key)
                depending_keys = (phase_type + k for k in ['', 'Weight', 'Pol', 'Onset', 'Err1', 'Err2'])
                for key in depending_keys:
                    self.delKey(key)
                self.delLabel(phase_type)
                self.redraw()
                return

        if ev.key == keys['setPickError']:
            # some keyPress events only make sense inside our matplotlib axes
            if not ev.inaxes in self.axs:
                return
            if phase_type in SEISMIC_PHASES:
                if phase_type not in dict:
                    return
                # Determine if left or right Error Pick
                if pickSample < dict[phase_type]:
                    key = phase_type + 'Err1'
                elif pickSample > dict[phase_type]:
                    key = phase_type + 'Err2'
                dict[key] = pickSample
                self.updateLine(key)
                self.redraw()
                abs_time = st[0].stats.starttime + dict[key]
                print "%s set at %.3f (%s)" % (KEY_FULLNAMES[key],
                                               dict[key], abs_time.isoformat())
                return

        if ev.key == keys['setMagMin']:
            # some keyPress events only make sense inside our matplotlib axes
            if not ev.inaxes in self.axs[1:3]:
                return
            if phase_type == 'Mag':
                if len(self.axs) < 2:
                    err = "Error: Magnitude picking only supported with a " + \
                          "minimum of 2 axes."
                    print >> sys.stderr, err
                    return
                # determine which dict keys to work with
                key = 'MagMin'
                key_other = 'MagMax'
                if ev.inaxes is self.axs[1]:
                    key += '1'
                    key_other += '1'
                elif ev.inaxes is self.axs[2]:
                    key += '2'
                    key_other += '2'
                keyT = key + 'T'
                keyT_other = key_other + 'T'
                # do the actual work
                ydata = ev.inaxes.lines[0].get_ydata() #get the first line hoping that it is the seismogram!
                cutoffSamples = xpos - MAG_PICKWINDOW #remember, how much samples there are before our small window! We have to add this number for our MagMinT estimation!
                dict[key] = np.min(ydata[xpos-MAG_PICKWINDOW:xpos+MAG_PICKWINDOW])
                # save time of magnitude minimum in seconds
                tmp_magtime = cutoffSamples + np.argmin(ydata[xpos-MAG_PICKWINDOW:xpos+MAG_PICKWINDOW])
                tmp_magtime = tmp_magtime / samp_rate
                dict[keyT] = tmp_magtime
                #delete old MagMax Pick, if new MagMin Pick is higher
                if key_other in dict and dict[key] > dict[key_other]:
                    self.delMagMarker(key_other)
                    self.delKey(key_other)
                    self.delKey(keyT_other)
                self.updateMagMarker(key)
                self.redraw()
                print "%s set: %s at %.3f" % (KEY_FULLNAMES[key], dict[key],
                                              dict[keyT])
                return

        if ev.key == keys['setMagMax']:
            # some keyPress events only make sense inside our matplotlib axes
            if not ev.inaxes in self.axs[1:3]:
                return
            if phase_type == 'Mag':
                if len(self.axs) < 2:
                    err = "Error: Magnitude picking only supported with a " + \
                          "minimum of 2 axes."
                    print >> sys.stderr, err
                    return
                # determine which dict keys to work with
                key = 'MagMax'
                key_other = 'MagMin'
                if ev.inaxes is self.axs[1]:
                    key += '1'
                    key_other += '1'
                elif ev.inaxes is self.axs[2]:
                    key += '2'
                    key_other += '2'
                keyT = key + 'T'
                keyT_other = key_other + 'T'
                # do the actual work
                ydata = ev.inaxes.lines[0].get_ydata() #get the first line hoping that it is the seismogram!
                cutoffSamples = xpos - MAG_PICKWINDOW #remember, how much samples there are before our small window! We have to add this number for our MagMaxT estimation!
                dict[key] = np.max(ydata[xpos-MAG_PICKWINDOW:xpos+MAG_PICKWINDOW])
                # save time of magnitude maximum in seconds
                tmp_magtime = cutoffSamples + np.argmax(ydata[xpos-MAG_PICKWINDOW:xpos+MAG_PICKWINDOW])
                tmp_magtime = tmp_magtime / samp_rate
                dict[keyT] = tmp_magtime
                #delete old MagMin Pick, if new MagMax Pick is lower
                if key_other in dict and dict[key] < dict[key_other]:
                    self.delMagMarker(key_other)
                    self.delKey(key_other)
                    self.delKey(keyT_other)
                self.updateMagMarker(key)
                self.redraw()
                print "%s set: %s at %.3f" % (KEY_FULLNAMES[key], dict[key],
                                              dict[keyT])
                return

        if ev.key == keys['delMagMinMax']:
            if phase_type == 'Mag':
                if ev.inaxes is self.axs[1]:
                    for key in ['MagMin1', 'MagMax1']:
                        self.delMagMarker(key)
                        self.delKey(key)
                elif ev.inaxes is self.axs[2]:
                    for key in ['MagMin2', 'MagMax2']:
                        self.delMagMarker(key)
                        self.delKey(key)
                else:
                    return
                self.redraw()
                return
        #######################################################################
        # End of key events related to picking                                #
        #######################################################################
        
        if ev.key == keys['switchWheelZoomAxis']:
            self.flagWheelZoomAmplitude = True

        # iterate the phase type combobox
        if ev.key == keys['switchPhase']:
            combobox = self.widgets.qComboBox_phaseType
            next = (combobox.currentIndex() + 1) % combobox.count()
            combobox.setCurrentIndex(next)
            print "Switching Phase button"
            return
            
        if ev.key == keys['prevStream']:
            if self.widgets.qToolButton_overview.isChecked():
                return
            self.on_qToolButton_previousStream_clicked()
            return

        if ev.key == keys['nextStream']:
            if self.widgets.qToolButton_overview.isChecked():
                return
            self.on_qToolButton_nextStream_clicked()
            return
    
    def __mpl_keyReleaseEvent(self, ev):
        if ev.key == self.keys['switchWheelZoomAxis']:
            self.flagWheelZoomAmplitude = False

    # Define zooming for the mouse wheel wheel
    def __mpl_wheelEvent(self, ev):
        # create mpl event from QEvent to get cursor position in data coords
        x = ev.x()
        y = self.canv.height() - ev.y()
        mpl_ev = MplMouseEvent("scroll_event", self.canv, x, y, "up", guiEvent=ev)
        # Calculate and set new axes boundaries from old ones
        if self.widgets.qToolButton_showMap.isChecked():
            ax = self.axEventMap
        else:
            ax = self.axs[0]
        (left, right) = ax.get_xbound()
        (bottom, top) = ax.get_ybound()
        # Get the keyboard modifiers. They are a enum type.
        # Use bitwise or to compare...hope this is correct.
        if ev.modifiers() == QtCore.Qt.NoModifier:
            # Zoom in.
            if ev.delta() < 0:
                left -= (mpl_ev.xdata - left) / 2
                right += (right - mpl_ev.xdata) / 2
                if self.widgets.qToolButton_showMap.isChecked():
                    top -= (mpl_ev.ydata - top) / 2
                    bottom += (bottom - mpl_ev.ydata) / 2
            # Zoom out.
            elif ev.delta() > 0:
                left += (mpl_ev.xdata - left) / 2
                right -= (right - mpl_ev.xdata) / 2
                if self.widgets.qToolButton_showMap.isChecked():
                    top += (mpl_ev.ydata - top) / 2
                    bottom -= (bottom - mpl_ev.ydata) / 2
        # Still able to use the dictionary.
        elif ev.modifiers() == getattr(QtCore.Qt,
                '%sModifier' % self.keys['switchWheelZoomAxis'].capitalize()):
            # Zoom in on wheel-up
            if ev.delta() < 0:
                top *= 2
                bottom *= 2
            # Zoom out on wheel-down
            elif ev.delta() > 0:
                top /= 2
                bottom /= 2
        ax.set_xbound(lower=left, upper=right)
        ax.set_ybound(lower=bottom, upper=top)
        self.redraw()
    
    # Define zoom reset for the mouse button 2 (always wheel wheel!?)
    def __mpl_mouseButtonPressEvent(self, ev):
        if self.widgets.qToolButton_showMap.isChecked():
            return
        # set widgetlock when pressing mouse buttons and dont show cursor
        # cursor should not be plotted when making a zoom selection etc.
        if ev.button in [1, 3]:
            self.multicursor.visible = False
            # reuse this event as setPick / setPickError event
            if ev.button == 1:
                if str(self.widgets.qComboBox_phaseType.currentText()) in SEISMIC_PHASES:
                    ev.key = self.keys['setPick']
                else:
                    ev.key = self.keys['setMagMin']
            elif ev.button == 3:
                if str(self.widgets.qComboBox_phaseType.currentText()) in SEISMIC_PHASES:
                    ev.key = self.keys['setPickError']
                else:
                    ev.key = self.keys['setMagMax']
            self.__mpl_keyPressEvent(ev)
            # XXX self.canv.widgetlock(self.toolbar)
        # show traces from start to end
        # (Use Z trace limits as boundaries)
        elif ev.button == 2:
            if self.widgets.qToolButton_showMap.isChecked():
                ax = self.axEventMap
            else:
                ax = self.axs[0]
            ax.set_xbound(lower=self.xMin, upper=self.xMax)
            ax.set_ybound(lower=self.yMin, upper=self.yMax)
            # Update all subplots
            self.redraw()
            print "Resetting axes"
    
    def __mpl_mouseButtonReleaseEvent(self, ev):
        if self.widgets.qToolButton_showMap.isChecked():
            return
        # release widgetlock when releasing mouse buttons
        if ev.button in [1, 3]:
            self.multicursor.visible = True
            # XXX self.canv.widgetlock.release(self.toolbar)

    def __mpl_motionNotifyEvent(self, ev):
        try:
            if ev.inaxes in self.axs:
                self.widgets.qLabel_xdata.setText(formatXTicklabels(ev.xdata))
                self.widgets.qLabel_ydata.setText("%.1f" % ev.ydata)
            else:
                self.widgets.qLabel_xdata.setText(str(ev.xdata))
                self.widgets.qLabel_ydata.setText(str(ev.ydata))
        except TypeError:
            pass
    
    #lookup multicursor source: http://matplotlib.sourcearchive.com/documentation/0.98.1/widgets_8py-source.html
    def multicursorReinit(self):
        self.canv.mpl_disconnect(self.multicursor.id1)
        self.canv.mpl_disconnect(self.multicursor.id2)
        self.multicursor.__init__(self.canv, self.axs, useblit=True,
                                  color='black', linewidth=1, ls='dotted')
        self.updateMulticursorColor()
        # XXX self.canv.widgetlock.release(self.toolbar)

    def updateMulticursorColor(self):
        phase_name = str(self.widgets.qComboBox_phaseType.currentText())
        color = PHASE_COLORS[phase_name]
        for l in self.multicursor.lines:
            l.set_color(color)

    def updateStreamNumberLabel(self):
        label = "%02i/%02i" % (self.stPt + 1, self.stNum)
        self.widgets.qLabel_streamNumber.setText(label)
    
    def updateStreamNameCombobox(self):
        self.widgets.qComboBox_streamName.setCurrentIndex(self.stPt)

    def updateStreamLabels(self):
        self.updateStreamNumberLabel()
        self.updateStreamNameCombobox()

    def load3dlocSyntheticPhases(self):
        files = PROGRAMS['3dloc']['files']
        try:
            fhandle = open(files['out'], 'rt')
            phaseList = fhandle.readlines()
            fhandle.close()
        except:
            return
        for key in ['Psynth', 'Ssynth']:
            self.delKey(key)
        for phase in phaseList[1:]:
            # example for a synthetic pick line from 3dloc:
            # RJOB P 2009 12 27 10 52 59.425 -0.004950 298.199524 136.000275
            # station phase YYYY MM DD hh mm ss.sss (picked time!) residual
            # (add this to get synthetic time) azimuth? incidenceangle?
            # XXX maybe we should avoid reading this absolute time and rather
            # use our dict['P'] or dict['S'] time and simple subtract the
            # residual to simplify things!?
            phase = phase.split()
            phStat = phase[0]
            phType = phase[1]
            phUTCTime = UTCDateTime(int(phase[2]), int(phase[3]),
                                    int(phase[4]), int(phase[5]),
                                    int(phase[6]), float(phase[7]))
            phResid = float(phase[8])
            # residual is defined as P-Psynth by NLLOC and 3dloc!
            phUTCTime = phUTCTime - phResid
            for st, dict in zip(self.streams, self.dicts):
                # check for matching station names
                if not phStat == st[0].stats.station.strip():
                    continue
                else:
                    # check if synthetic pick is within time range of stream
                    if (phUTCTime > st[0].stats.endtime or \
                        phUTCTime < st[0].stats.starttime):
                        err = "Warning: Synthetic pick outside timespan."
                        print >> sys.stderr, err
                        continue
                    else:
                        # phSeconds is the time in seconds after the stream-
                        # starttime at which the time of the synthetic phase
                        # is located
                        phSeconds = phUTCTime - st[0].stats.starttime
                        if phType == 'P':
                            dict['Psynth'] = phSeconds
                            dict['Pres'] = phResid
                        elif phType == 'S':
                            dict['Ssynth'] = phSeconds
                            dict['Sres'] = phResid
        for key in ['Psynth', 'Ssynth']:
            self.updateLine(key)
            self.updateLabel(key)
        self.redraw()

    def do3dLoc(self):
        prog_dict = PROGRAMS['3dloc']
        files = prog_dict['files']
        self.setXMLEventID()
        precall = prog_dict['PreCall']
        precall(prog_dict)

        f = open(files['in'], 'wt')
        network = "BW"
        fmt = "%04s  %s        %s %5.3f -999.0 0.000 -999. 0.000 T__DR_ %9.6f %9.6f %8.6f\n"
        self.coords = []
        for st, dict in zip(self.streams, self.dicts):
            lon = dict['StaLon']
            lat = dict['StaLat']
            ele = dict['StaEle']
            self.coords.append([lon, lat])
            # if the error picks are not set, we use a default of three samples
            default_error = 3 / st[0].stats.sampling_rate
            if 'P' in dict:
                t = st[0].stats.starttime
                t += dict['P']
                date = t.strftime("%Y %m %d %H %M %S")
                date += ".%03d" % (t.microsecond / 1e3 + 0.5)
                if 'PErr1' in dict:
                    error_1 = dict['PErr1']
                else:
                    err = "Warning: Left error pick for P missing. " + \
                          "Using a default of 3 samples left of P."
                    print >> sys.stderr, err
                    error_1 = dict['P'] - default_error
                if 'PErr2' in dict:
                    error_2 = dict['PErr2']
                else:
                    err = "Warning: Right error pick for P missing. " + \
                          "Using a default of 3 samples right of P."
                    print >> sys.stderr, err
                    error_2 = dict['P'] + default_error
                delta = error_2 - error_1
                f.write(fmt % (dict['Station'], 'P', date, delta, lon, lat,
                               ele))
            if 'S' in dict:
                t = st[0].stats.starttime
                t += dict['S']
                date = t.strftime("%Y %m %d %H %M %S")
                date += ".%03d" % (t.microsecond / 1e3 + 0.5)
                if 'SErr1' in dict:
                    error_1 = dict['SErr1']
                else:
                    err = "Warning: Left error pick for S missing. " + \
                          "Using a default of 3 samples left of S."
                    print >> sys.stderr, err
                    error_1 = dict['S'] - default_error
                if 'SErr2' in dict:
                    error_2 = dict['SErr2']
                else:
                    err = "Warning: Right error pick for S missing. " + \
                          "Using a default of 3 samples right of S."
                    print >> sys.stderr, err
                    error_2 = dict['S'] + default_error
                delta = error_2 - error_1
                f.write(fmt % (dict['Station'], 'S', date, delta, lon, lat,
                               ele))
        f.close()
        print 'Phases for 3Dloc:'
        self.catFile(files['in'])
        call = prog_dict['Call']
        (msg, err, returncode) = call(prog_dict)
        print msg
        print >> sys.stderr, err
        print '--> 3dloc finished'
        self.catFile(files['out'])

    def doFocmec(self):
        prog_dict = PROGRAMS['focmec']
        files = prog_dict['files']
        f = open(files['phases'], 'wt')
        f.write("\n") #first line is ignored!
        #Fortran style! 1: Station 2: Azimuth 3: Incident 4: Polarity
        #fmt = "ONTN  349.00   96.00C"
        fmt = "%4s  %6.2f  %6.2f%1s\n"
        count = 0
        for dict in self.dicts:
            if 'PAzim' not in dict or 'PInci' not in dict or 'PPol' not in dict:
                continue
            sta = dict['Station'][:4] #focmec has only 4 chars
            azim = dict['PAzim']
            inci = dict['PInci']
            if dict['PPol'] == 'up':
                pol = 'U'
            elif dict['PPol'] == 'poorup':
                pol = '+'
            elif dict['PPol'] == 'down':
                pol = 'D'
            elif dict['PPol'] == 'poordown':
                pol = '-'
            else:
                continue
            count += 1
            f.write(fmt % (sta, azim, inci, pol))
        f.close()
        print 'Phases for focmec: %i' % count
        self.catFile(files['phases'])
        call = prog_dict['Call']
        (msg, err, returncode) = call(prog_dict)
        print msg
        print >> sys.stderr, err
        if returncode == 1:
            err = "Error: focmec did not find a suitable solution!"
            print >> sys.stderr, err
            return
        print '--> focmec finished'
        lines = open(files['summary'], "rt").readlines()
        print '%i suitable solutions found:' % len(lines)
        self.focMechList = []
        for line in lines:
            line = line.split()
            tempdict = {}
            tempdict['Program'] = "focmec"
            tempdict['Dip'] = float(line[0])
            tempdict['Strike'] = float(line[1])
            tempdict['Rake'] = float(line[2])
            tempdict['Errors'] = int(float(line[3])) # not used in xml
            tempdict['Station Polarity Count'] = count
            tempdict['Possible Solution Count'] = len(lines)
            print "Dip: %6.2f  Strike: %6.2f  Rake: %6.2f  Errors: %i/%i" % \
                    (tempdict['Dip'], tempdict['Strike'], tempdict['Rake'],
                     tempdict['Errors'], tempdict['Station Polarity Count'])
            self.focMechList.append(tempdict)
        self.focMechCount = len(self.focMechList)
        self.focMechCurrent = 0
        print "selecting Focal Mechanism No.  1 of %2i:" % self.focMechCount
        self.dictFocalMechanism = self.focMechList[0]
        dF = self.dictFocalMechanism
        print "Dip: %6.2f  Strike: %6.2f  Rake: %6.2f  Errors: %i/%i" % \
                (dF['Dip'], dF['Strike'], dF['Rake'], dF['Errors'],
                 dF['Station Polarity Count'])

    def nextFocMec(self):
        if self.focMechCount is None:
            return
        self.focMechCurrent = (self.focMechCurrent + 1) % self.focMechCount
        self.dictFocalMechanism = self.focMechList[self.focMechCurrent]
        dF = self.dictFocalMechanism
        print "selecting Focal Mechanism No. %2i of %2i:" % \
                (self.focMechCurrent + 1, self.focMechCount)
        print "Dip: %6.2f  Strike: %6.2f  Rake: %6.2f  Errors: %i/%i" % \
                (dF['Dip'], dF['Strike'], dF['Rake'], dF['Errors'],
                 dF['Station Polarity Count'])
    
    def drawFocMec(self):
        if self.dictFocalMechanism == {}:
            err = "Error: No focal mechanism data!"
            print >> sys.stderr, err
            return
        # make up the figure:
        fig = self.fig
        self.axsFocMec = []
        axs = self.axsFocMec
        fig.subplots_adjust(left=0, bottom=0, right=1, top=1)
        
        # plot the selected solution
        dF = self.dictFocalMechanism
        axs.append(Beachball([dF['Strike'], dF['Dip'], dF['Rake']], fig=fig))
        # plot the alternative solutions
        if self.focMechList != []:
            for dict in self.focMechList:
                axs.append(Beachball([dict['Strike'], dict['Dip'],
                          dict['Rake']],
                          nofill=True, fig=fig, edgecolor='k',
                          linewidth=1., alpha=0.3))
        text = "Focal Mechanism (%i of %i)" % \
               (self.focMechCurrent + 1, self.focMechCount)
        text += "\nDip: %6.2f  Strike: %6.2f  Rake: %6.2f" % \
                (dF['Dip'], dF['Strike'], dF['Rake'])
        if 'Errors' in dF:
            text += "\nErrors: %i/%i" % (dF['Errors'],
                                         dF['Station Polarity Count'])
        else:
            text += "\nUsed Polarities: %i" % dF['Station Polarity Count']
        #fig.canvas.set_window_title("Focal Mechanism (%i of %i)" % \
        #        (self.focMechCurrent + 1, self.focMechCount))
        fig.subplots_adjust(top=0.88) # make room for suptitle
        # values 0.02 and 0.96 fit best over the outer edges of beachball
        #ax = fig.add_axes([0.00, 0.02, 1.00, 0.96], polar=True)
        self.axFocMecStations = fig.add_axes([0.00,0.02,1.00,0.84], polar=True)
        ax = self.axFocMecStations
        ax.set_title(text)
        ax.set_axis_off()
        for dict in self.dicts:
            if 'PAzim' in dict and 'PInci' in dict and 'PPol' in dict:
                if dict['PPol'] == "up":
                    color = "black"
                elif dict['PPol'] == "poorup":
                    color = "darkgrey"
                elif dict['PPol'] == "poordown":
                    color = "lightgrey"
                elif dict['PPol'] == "down":
                    color = "white"
                else:
                    continue
                # southern hemisphere projection
                if dict['PInci'] > 90:
                    inci = 180. - dict['PInci']
                    azim = -180. + dict['PAzim']
                else:
                    inci = dict['PInci']
                    azim = dict['PAzim']
                #we have to hack the azimuth because of the polar plot
                #axes orientation
                plotazim = (np.pi / 2.) - ((azim / 180.) * np.pi)
                ax.scatter([plotazim], [inci], facecolor=color)
                ax.text(plotazim, inci, " " + dict['Station'], va="top")
        #this fits the 90 degree incident value to the beachball edge best
        ax.set_ylim([0., 91])
        self.canv.draw()

    def delFocMec(self):
        if hasattr(self, "axFocMecStations"):
            self.fig.delaxes(self.axFocMecStations)
            del self.axFocMecStations
        if hasattr(self, "axsFocMec"):
            for ax in self.axsFocMec:
                if ax in self.fig.axes: 
                    self.fig.delaxes(ax)
                del ax

    def doHyp2000(self):
        """
        Writes input files for hyp2000 and starts the hyp2000 program via a
        system call.
        """
        prog_dict = PROGRAMS['hyp_2000']
        files = prog_dict['files']
        self.setXMLEventID()
        precall = prog_dict['PreCall']
        precall(prog_dict)

        f = open(files['phases'], 'wt')
        phases_hypo71 = self.dicts2hypo71Phases()
        f.write(phases_hypo71)
        f.close()

        f2 = open(files['stations'], 'wt')
        stations_hypo71 = self.dicts2hypo71Stations()
        f2.write(stations_hypo71)
        f2.close()

        print 'Phases for Hypo2000:'
        self.catFile(files['phases'])
        print 'Stations for Hypo2000:'
        self.catFile(files['stations'])

        call = prog_dict['Call']
        (msg, err, returncode) = call(prog_dict)
        print msg
        print >> sys.stderr, err
        print '--> hyp2000 finished'
        self.catFile(files['summary'])

    def doNLLoc(self):
        """
        Writes input files for NLLoc and starts the NonLinLoc program via a
        system call.
        """
        prog_dict = PROGRAMS['nlloc']
        files = prog_dict['files']
        # determine which model should be used in location
        controlfilename = "locate_%s.nlloc" % \
                          str(self.widgets.qComboBox_nllocModel.currentText())

        self.setXMLEventID()
        precall = prog_dict['PreCall']
        precall(prog_dict)

        f = open(files['phases'], 'wt')
        phases_hypo71 = self.dicts2hypo71Phases()
        f.write(phases_hypo71)
        f.close()

        print 'Phases for NLLoc:'
        self.catFile(files['phases'])

        call = prog_dict['Call']
        (msg, err, returncode) = call(prog_dict, controlfilename)
        print msg
        print >> sys.stderr, err
        print '--> NLLoc finished'
        self.catFile(files['summary'])

    def catFile(self, file):
        lines = open(file, "rt").readlines()
        msg = ""
        for line in lines:
            msg += line
        print msg

    def loadNLLocOutput(self):
        files = PROGRAMS['nlloc']['files']
        lines = open(files['summary'], "rt").readlines()
        if not lines:
            err = "Error: NLLoc output file (%s) does not exist!" % \
                    files['summary']
            print >> sys.stderr, err
            return
        # goto maximum likelihood origin location info line
        try:
            line = lines.pop(0)
            while not line.startswith("HYPOCENTER"):
                line = lines.pop(0)
        except:
            err = "Error: No correct location info found in NLLoc " + \
                  "outputfile (%s)!" % files['summary']
            print >> sys.stderr, err
            return
        
        line = line.split()
        x = float(line[2])
        y = float(line[4])
        depth = - float(line[6]) # depth: negative down!
        
        lon, lat = gk2lonlat(x, y)
        
        # goto origin time info line
        try:
            line = lines.pop(0)
            while not line.startswith("GEOGRAPHIC  OT"):
                line = lines.pop(0)
        except:
            err = "Error: No correct location info found in NLLoc " + \
                  "outputfile (%s)!" % files['summary']
            print >> sys.stderr, err
            return
        
        line = line.split()
        year = int(line[2])
        month = int(line[3])
        day = int(line[4])
        hour = int(line[5])
        minute = int(line[6])
        seconds = float(line[7])
        time = UTCDateTime(year, month, day, hour, minute, seconds)

        # goto location quality info line
        try:
            line = lines.pop(0)
            while not line.startswith("QUALITY"):
                line = lines.pop(0)
        except:
            err = "Error: No correct location info found in NLLoc " + \
                  "outputfile (%s)!" % files['summary']
            print >> sys.stderr, err
            return
        
        line = line.split()
        rms = float(line[8])
        gap = int(line[12])

        # goto location quality info line
        try:
            line = lines.pop(0)
            while not line.startswith("STATISTICS"):
                line = lines.pop(0)
        except:
            err = "Error: No correct location info found in NLLoc " + \
                  "outputfile (%s)!" % files['summary']
            print >> sys.stderr, err
            return
        
        line = line.split()
        # read in the error ellipsoid representation of the location error.
        # this is given as azimuth/dip/length of axis 1 and 2 and as length
        # of axis 3.
        azim1 = float(line[20])
        dip1 = float(line[22])
        len1 = float(line[24])
        azim2 = float(line[26])
        dip2 = float(line[28])
        len2 = float(line[30])
        len3 = float(line[32])

        errX, errY, errZ = errorEllipsoid2CartesianErrors(azim1, dip1, len1,
                                                          azim2, dip2, len2,
                                                          len3)
        
        # XXX
        # NLLOC uses error ellipsoid for 68% confidence interval relating to
        # one standard deviation in the normal distribution.
        # We multiply all errors by 2 to approximately get the 95% confidence
        # level (two standard deviations)...
        errX *= 2
        errY *= 2
        errZ *= 2

        # determine which model was used:
        # XXX handling of path extremely hackish! to be improved!!
        dirname = os.path.dirname(files['summary'])
        controlfile = os.path.join(dirname, "last.in")
        lines2 = open(controlfile, "rt").readlines()
        line2 = lines2.pop()
        while not line2.startswith("LOCFILES"):
            line2 = lines2.pop()
        line2 = line2.split()
        model = line2[3]
        model = model.split("/")[-1]

        # assign origin info
        dO = self.dictOrigin
        dO['Longitude'] = lon
        dO['Latitude'] = lat
        dO['Depth'] = depth
        dO['Longitude Error'] = errX
        dO['Latitude Error'] = errY
        dO['Depth Error'] = errZ
        dO['Standarderror'] = rms #XXX stimmt diese Zuordnung!!!?!
        dO['Azimuthal Gap'] = gap
        dO['Depth Type'] = "from location program"
        dO['Earth Model'] = model
        dO['Time'] = time
        
        # goto synthetic phases info lines
        try:
            line = lines.pop(0)
            while not line.startswith("PHASE ID"):
                line = lines.pop(0)
        except:
            err = "Error: No correct synthetic phase info found in NLLoc " + \
                  "outputfile (%s)!" % files['summary']
            print >> sys.stderr, err
            return

        # remove all non phase-info-lines from bottom of list
        try:
            badline = lines.pop()
            while not badline.startswith("END_PHASE"):
                badline = lines.pop()
        except:
            err = "Error: Could not remove unwanted lines at bottom of " + \
                  "NLLoc outputfile (%s)!" % files['summary']
            print >> sys.stderr, err
            return
        
        dO['used P Count'] = 0
        dO['used S Count'] = 0

        # go through all phase info lines
        for line in lines:
            line = line.split()
            # check which type of phase
            if line[4] == "P":
                type = "P"
            elif line[4] == "S":
                type = "S"
            else:
                continue
            # get values from line
            station = line[0]
            azimuth = float(line[23])
            incident = float(line[24])
            # if we do the location on traveltime-grids without angle-grids we
            # do not get ray azimuth/incidence. but we can at least use the
            # station to hypocenter azimuth which is very close (~2 deg) to the
            # ray azimuth
            if azimuth == 0.0 and incident == 0.0:
                azimuth = float(line[22])
                incident = np.nan
            if line[3] == "I":
                onset = "impulsive"
            elif line[3] == "E":
                onset = "emergent"
            else:
                onset = None
            if line[5] == "U":
                polarity = "up"
            elif line[5] == "D":
                polarity = "down"
            else:
                polarity = None
            res = float(line[16])
            weight = float(line[17])

            # search for streamnumber corresponding to pick
            streamnum = None
            for i, dict in enumerate(self.dicts):
                if station.strip() != dict['Station']:
                    continue
                else:
                    streamnum = i
                    break
            if streamnum is None:
                err = "Warning: Did not find matching stream for pick " + \
                      "data with station id: \"%s\"" % station.strip()
                print >> sys.stderr, err
                continue
            
            # assign synthetic phase info
            dict = self.dicts[streamnum]
            if type == "P":
                dO['used P Count'] += 1
                #dict['Psynth'] = res + dict['P']
                # residual is defined as P-Psynth by NLLOC and 3dloc!
                dict['Psynth'] = dict['P'] - res
                dict['Pres'] = res
                dict['PAzim'] = azimuth
                dict['PInci'] = incident
                if onset:
                    dict['POnset'] = onset
                if polarity:
                    dict['PPol'] = polarity
                # we use weights 0,1,2,3 but NLLoc outputs floats...
                dict['PsynthWeight'] = weight
            elif type == "S":
                dO['used S Count'] += 1
                # residual is defined as S-Ssynth by NLLOC and 3dloc!
                dict['Ssynth'] = dict['S'] - res
                dict['Sres'] = res
                dict['SAzim'] = azimuth
                dict['SInci'] = incident
                if onset:
                    dict['SOnset'] = onset
                if polarity:
                    dict['SPol'] = polarity
                # we use weights 0,1,2,3 but NLLoc outputs floats...
                dict['SsynthWeight'] = weight
        dO['used Station Count'] = len(self.dicts)
        for dict in self.dicts:
            if not ('Psynth' in dict or 'Ssynth' in dict):
                dO['used Station Count'] -= 1

    def loadHyp2000Data(self):
        files = PROGRAMS['hyp_2000']['files']
        #self.load3dlocSyntheticPhases()
        lines = open(files['summary'], "rt").readlines()
        if lines == []:
            err = "Error: Hypo2000 output file (%s) does not exist!" % \
                    files['summary']
            print >> sys.stderr, err
            return
        # goto origin info line
        while True:
            try:
                line = lines.pop(0)
            except:
                break
            if line.startswith(" YEAR MO DA  --ORIGIN--"):
                break
        try:
            line = lines.pop(0)
        except:
            err = "Error: No location info found in Hypo2000 outputfile " + \
                  "(%s)!" % files['summary']
            print >> sys.stderr, err
            return

        year = int(line[1:5])
        month = int(line[6:8])
        day = int(line[9:11])
        hour = int(line[13:15])
        minute = int(line[15:17])
        seconds = float(line[18:23])
        time = UTCDateTime(year, month, day, hour, minute, seconds)
        lat_deg = int(line[25:27])
        lat_min = float(line[28:33])
        lat = lat_deg + (lat_min / 60.)
        if line[27] == "S":
            lat = -lat
        lon_deg = int(line[35:38])
        lon_min = float(line[39:44])
        lon = lon_deg + (lon_min / 60.)
        if line[38] == " ":
            lon = -lon
        depth = -float(line[46:51]) # depth: negative down!
        rms = float(line[52:57])
        errXY = float(line[58:63])
        errZ = float(line[64:69])

        # goto next origin info line
        while True:
            try:
                line = lines.pop(0)
            except:
                break
            if line.startswith(" NSTA NPHS  DMIN MODEL"):
                break
        line = lines.pop(0)

        #model = line[17:22].strip()
        gap = int(line[23:26])

        line = lines.pop(0)
        model = line[49:].strip()

        # assign origin info
        dO = self.dictOrigin
        dO['Longitude'] = lon
        dO['Latitude'] = lat
        dO['Depth'] = depth
        dO['Longitude Error'] = errXY
        dO['Latitude Error'] = errXY
        dO['Depth Error'] = errZ
        dO['Standarderror'] = rms #XXX stimmt diese Zuordnung!!!?!
        dO['Azimuthal Gap'] = gap
        dO['Depth Type'] = "from location program"
        dO['Earth Model'] = model
        dO['Time'] = time
        
        # goto station and phases info lines
        while True:
            try:
                line = lines.pop(0)
            except:
                break
            if line.startswith(" STA NET COM L CR DIST AZM"):
                break
        
        dO['used P Count'] = 0
        dO['used S Count'] = 0
        #XXX caution: we sometimes access the prior element!
        for i in range(len(lines)):
            # check which type of phase
            if lines[i][32] == "P":
                type = "P"
            elif lines[i][32] == "S":
                type = "S"
            else:
                continue
            # get values from line
            station = lines[i][0:6].strip()
            if station == "":
                station = lines[i-1][0:6].strip()
                azimuth = int(lines[i-1][23:26])
                #XXX check, if incident is correct!!
                incident = int(lines[i-1][27:30])
            else:
                azimuth = int(lines[i][23:26])
                #XXX check, if incident is correct!!
                incident = int(lines[i][27:30])
            if lines[i][31] == "I":
                onset = "impulsive"
            elif lines[i][31] == "E":
                onset = "emergent"
            else:
                onset = None
            if lines[i][33] == "U":
                polarity = "up"
            elif lines[i][33] == "D":
                polarity = "down"
            else:
                polarity = None
            res = float(lines[i][61:66])
            weight = float(lines[i][68:72])

            # search for streamnumber corresponding to pick
            streamnum = None
            for i, dict in enumerate(self.dicts):
                if station.strip() != dict['Station']:
                    continue
                else:
                    streamnum = i
                    break
            if streamnum is None:
                err = "Warning: Did not find matching stream for pick " + \
                      "data with station id: \"%s\"" % station.strip()
                print >> sys.stderr, err
                continue
            
            # assign synthetic phase info
            dict = self.dicts[streamnum]
            if type == "P":
                dO['used P Count'] += 1
                # residual is defined as P-Psynth by NLLOC and 3dloc!
                # XXX does this also hold for hyp2000???
                dict['Psynth'] = dict['P'] - res
                dict['Pres'] = res
                dict['PAzim'] = azimuth
                dict['PInci'] = incident
                if onset:
                    dict['POnset'] = onset
                if polarity:
                    dict['PPol'] = polarity
                # we use weights 0,1,2,3 but hypo2000 outputs floats...
                dict['PsynthWeight'] = weight
            elif type == "S":
                dO['used S Count'] += 1
                # residual is defined as S-Ssynth by NLLOC and 3dloc!
                # XXX does this also hold for hyp2000???
                dict['Ssynth'] = dict['S'] - res
                dict['Sres'] = res
                dict['SAzim'] = azimuth
                dict['SInci'] = incident
                if onset:
                    dict['SOnset'] = onset
                if polarity:
                    dict['SPol'] = polarity
                # we use weights 0,1,2,3 but hypo2000 outputs floats...
                dict['SsynthWeight'] = weight
        dO['used Station Count'] = len(self.dicts)
        for dict in self.dicts:
            if not ('Psynth' in dict or 'Ssynth' in dict):
                dO['used Station Count'] -= 1

    def load3dlocData(self):
        files = PROGRAMS['3dloc']['files']
        #self.load3dlocSyntheticPhases()
        event = open(files['out'], "rt").readline().split()
        dO = self.dictOrigin
        dO['Longitude'] = float(event[8])
        dO['Latitude'] = float(event[9])
        dO['Depth'] = float(event[10])
        dO['Longitude Error'] = float(event[11])
        dO['Latitude Error'] = float(event[12])
        dO['Depth Error'] = float(event[13])
        dO['Standarderror'] = float(event[14])
        dO['Azimuthal Gap'] = float(event[15])
        dO['Depth Type'] = "from location program"
        dO['Earth Model'] = "STAUFEN"
        dO['Time'] = UTCDateTime(int(event[2]), int(event[3]), int(event[4]),
                                 int(event[5]), int(event[6]), float(event[7]))
        dO['used P Count'] = 0
        dO['used S Count'] = 0
        lines = open(files['in'], "rt").readlines()
        for line in lines:
            pick = line.split()
            for st in self.streams:
                if pick[0].strip() == st[0].stats.station.strip():
                    if pick[1] == 'P':
                        dO['used P Count'] += 1
                    elif pick[1] == 'S':
                        dO['used S Count'] += 1
                    break
        lines = open(files['out'], "rt").readlines()
        for line in lines[1:]:
            pick = line.split()
            for st, dict in zip(self.streams, self.dicts):
                if pick[0].strip() == st[0].stats.station.strip():
                    if pick[1] == 'P':
                        dict['PAzim'] = float(pick[9])
                        dict['PInci'] = float(pick[10])
                    elif pick[1] == 'S':
                        dict['SAzim'] = float(pick[9])
                        dict['SInci'] = float(pick[10])
                    break
        dO['used Station Count'] = len(self.dicts)
        for dict in self.dicts:
            if not ('Psynth' in dict or 'Ssynth' in dict):
                dO['used Station Count'] -= 1
    
    def updateNetworkMag(self):
        print "updating network magnitude..."
        dM = self.dictMagnitude
        dM['Station Count'] = 0
        dM['Magnitude'] = 0
        staMags = []
        for dict in self.dicts:
            if dict['MagUse'] and 'Mag' in dict:
                print "%s: %.1f" % (dict['Station'], dict['Mag'])
                dM['Station Count'] += 1
                dM['Magnitude'] += dict['Mag']
                staMags.append(dict['Mag'])
        if dM['Station Count'] == 0:
            dM['Magnitude'] = np.nan
            dM['Uncertainty'] = np.nan
        else:
            dM['Magnitude'] /= dM['Station Count']
            dM['Uncertainty'] = np.var(staMags)
        print "new network magnitude: %.2f (Variance: %.2f)" % \
                (dM['Magnitude'], dM['Uncertainty'])
        self.netMagLabel = '\n\n\n\n\n %.2f (Var: %.2f)' % (dM['Magnitude'],
                                                           dM['Uncertainty'])
        if hasattr(self, 'netMagText'):
            self.netMagText.set_text(self.netMagLabel)
    
    def calculateEpiHypoDists(self):
        if not 'Longitude' in self.dictOrigin or \
           not 'Latitude' in self.dictOrigin:
            err = "Error: No coordinates for origin!"
            print >> sys.stderr, err
        dO = self.dictOrigin
        epidists = []
        for dict in self.dicts:
            x, y = utlGeoKm(dO['Longitude'], dO['Latitude'],
                            dict['StaLon'], dict['StaLat'])
            z = abs(dict['StaEle'] - dO['Depth'])
            dict['distX'] = x
            dict['distY'] = y
            dict['distZ'] = z
            dict['distEpi'] = np.sqrt(x**2 + y**2)
            # Median and Max/Min of epicentral distances should only be used
            # for stations with a pick that goes into the location.
            # The epicentral distance of all other stations may be needed for
            # magnitude estimation nonetheless.
            if 'Psynth' in dict or 'Ssynth' in dict:
                epidists.append(dict['distEpi'])
            dict['distHypo'] = np.sqrt(x**2 + y**2 + z**2)
        dO['Maximum Distance'] = max(epidists)
        dO['Minimum Distance'] = min(epidists)
        dO['Median Distance'] = np.median(epidists)

    def calculateStationMagnitudes(self):
        for st, dict in zip(self.streams, self.dicts):
            if 'MagMin1' in dict and 'MagMin2' in dict and \
               'MagMax1' in dict and 'MagMax2' in dict:
                
                amp = dict['MagMax1'] - dict['MagMin1']
                timedelta = abs(dict['MagMax1T'] - dict['MagMin1T'])
                mag = estimateMagnitude(dict['pazN'], amp, timedelta,
                                        dict['distHypo'])
                amp = dict['MagMax2'] - dict['MagMin2']
                timedelta = abs(dict['MagMax2T'] - dict['MagMin2T'])
                mag += estimateMagnitude(dict['pazE'], amp, timedelta,
                                         dict['distHypo'])
                mag /= 2.
                dict['Mag'] = mag
                dict['MagChannel'] = '%s,%s' % (st[1].stats.channel,
                                                st[2].stats.channel)
                print 'calculated new magnitude for %s: %0.2f (channels: %s)' \
                      % (dict['Station'], dict['Mag'], dict['MagChannel'])
            
            elif 'MagMin1' in dict and 'MagMax1' in dict:
                amp = dict['MagMax1'] - dict['MagMin1']
                timedelta = abs(dict['MagMax1T'] - dict['MagMin1T'])
                mag = estimateMagnitude(dict['pazN'], amp, timedelta,
                                        dict['distHypo'])
                dict['Mag'] = mag
                dict['MagChannel'] = '%s' % st[1].stats.channel
                print 'calculated new magnitude for %s: %0.2f (channels: %s)' \
                      % (dict['Station'], dict['Mag'], dict['MagChannel'])
            
            elif 'MagMin2' in dict and 'MagMax2' in dict:
                amp = dict['MagMax2'] - dict['MagMin2']
                timedelta = abs(dict['MagMax2T'] - dict['MagMin2T'])
                mag = estimateMagnitude(dict['pazE'], amp, timedelta,
                                        dict['distHypo'])
                dict['Mag'] = mag
                dict['MagChannel'] = '%s' % st[2].stats.channel
                print 'calculated new magnitude for %s: %0.2f (channels: %s)' \
                      % (dict['Station'], dict['Mag'], dict['MagChannel'])
    
    #see http://www.scipy.org/Cookbook/LinearRegression for alternative routine
    #XXX replace with drawWadati()
    def drawWadati(self):
        """
        Shows a Wadati diagram plotting P time in (truncated) Julian seconds
        against S-P time for every station and doing a linear regression
        using rpy. An estimate of Vp/Vs is given by the slope + 1.
        """
        try:
            import rpy
        except:
            err = "Error: Package rpy could not be imported!\n" + \
                  "(We should switch to scipy polyfit, anyway!)"
            print >> sys.stderr, err
            return
        pTimes = []
        spTimes = []
        stations = []
        for st, dict in zip(self.streams, self.dicts):
            if 'P' in dict and 'S' in dict:
                p = st[0].stats.starttime
                p += dict['P']
                p = "%.3f" % p.getTimeStamp()
                p = float(p[-7:])
                pTimes.append(p)
                sp = dict['S'] - dict['P']
                spTimes.append(sp)
                stations.append(dict['Station'])
            else:
                continue
        if len(pTimes) < 2:
            err = "Error: Less than 2 P-S Pairs!"
            print >> sys.stderr, err
            return
        my_lsfit = rpy.r.lsfit(pTimes, spTimes)
        gradient = my_lsfit['coefficients']['X']
        intercept = my_lsfit['coefficients']['Intercept']
        vpvs = gradient + 1.
        ressqrsum = 0.
        for res in my_lsfit['residuals']:
            ressqrsum += (res ** 2)
        y0 = 0.
        x0 = - (intercept / gradient)
        x1 = max(pTimes)
        y1 = (gradient * float(x1)) + intercept

        fig = self.fig
        self.axWadati = fig.add_subplot(111)
        self.fig.subplots_adjust(bottom=0.07, top=0.95, left=0.07, right=0.98)
        ax = self.axWadati
        ax = fig.add_subplot(111)

        ax.scatter(pTimes, spTimes)
        for i, station in enumerate(stations):
            ax.text(pTimes[i], spTimes[i], station, va = "top")
        ax.plot([x0, x1], [y0, y1])
        ax.axhline(0, color="blue", ls=":")
        # origin time estimated by wadati plot
        ax.axvline(x0, color="blue", ls=":",
                   label="origin time from wadati diagram")
        # origin time from event location
        if 'Time' in self.dictOrigin:
            otime = "%.3f" % self.dictOrigin['Time'].getTimeStamp()
            otime = float(otime[-7:])
            ax.axvline(otime, color="red", ls=":",
                       label="origin time from event location")
        ax.text(0.1, 0.7, "Vp/Vs: %.2f\nSum of squared residuals: %.3f" % \
                (vpvs, ressqrsum), transform=ax.transAxes)
        ax.text(0.1, 0.1, "Origin time from event location", color="red",
                transform=ax.transAxes)
        #ax.axis("auto")
        ax.set_xlim(min(x0 - 1, otime - 1), max(pTimes) + 1)
        ax.set_ylim(-1, max(spTimes) + 1)
        ax.set_xlabel("absolute P times (julian seconds, truncated)")
        ax.set_ylabel("P-S times (seconds)")
        ax.set_title("Wadati Diagram")
        self.canv.draw()

    def delWadati(self):
        if hasattr(self, "axWadati"):
            self.fig.delaxes(self.axWadati)
            del self.axWadati

    def drawStreamOverview(self):
        stNum = len(self.streams)
        fig = self.fig
        axs = []
        self.axs = axs
        plts = []
        self.plts = plts
        trans = []
        self.trans = trans
        t = []
        #we start all our x-axes at 0 with the starttime of the first (Z) trace
        starttime_global = self.streams[0].select(component="Z")[0].stats.starttime
        for i, st in enumerate(self.streams):
            tr = st.select(component="Z")[0]
            #make sure that the relative times of the x-axes get mapped to our
            #global stream (absolute) starttime (starttime of first (Z) trace)
            starttime_local = tr.stats.starttime - starttime_global
            dt = 1. / tr.stats.sampling_rate
            sampletimes = np.arange(starttime_local,
                    starttime_local + (dt * tr.stats.npts), dt)
            # sometimes our arange is one item too long (why??), so we just cut
            # off the last item if this is the case
            if len(sampletimes) == tr.stats.npts + 1:
                sampletimes = sampletimes[:-1]
            t.append(sampletimes)
            if i == 0:
                ax = fig.add_subplot(stNum, 1, i+1)
            else:
                ax = fig.add_subplot(stNum, 1, i+1, sharex=axs[0], sharey=axs[0])
                ax.xaxis.set_ticks_position("top")
            axs.append(ax)
            trans.append(matplotlib.transforms.blended_transform_factory(ax.transData, ax.transAxes))
            ax.xaxis.set_major_formatter(FuncFormatter(formatXTicklabels))
            if self.widgets.qToolButton_filter.isChecked():
                tr = tr.copy()
                self._filter(tr)
            # normalize with overall sensitivity and convert to nm/s
            # if not explicitly deactivated on command line
            if not self.options.nonormalization:
                plts.append(ax.plot(sampletimes, tr.data / tr.stats.paz.sensitivity * 1e9, color='k', zorder=1000)[0])
            else:
                plts.append(ax.plot(sampletimes, tr.data, color='k', zorder=1000)[0])
            tr_id = "%s.%s.%s.%s" % (tr.stats.network, tr.stats.station, tr.stats.location, tr.stats.channel)
            ax.text(0.01, 0.95, tr_id, va="top", ha="left", fontsize=18,
                    family='monospace', color="b", zorder=10000,
                    transform=ax.transAxes)
        axs[-1].xaxis.set_ticks_position("both")
        self.supTit = fig.suptitle("%s.%03d -- %s.%03d" % (tr.stats.starttime.strftime("%Y-%m-%d  %H:%M:%S"),
                                                         tr.stats.starttime.microsecond / 1e3 + 0.5,
                                                         tr.stats.endtime.strftime("%H:%M:%S"),
                                                         tr.stats.endtime.microsecond / 1e3 + 0.5), ha="left", va="bottom", x=0.01, y=0.01)
        self.xMin, self.xMax = axs[0].get_xlim()
        self.yMin, self.yMax = axs[0].get_ylim()
        fig.subplots_adjust(bottom=0.001, hspace=0.000, right=0.999, top=0.999, left=0.001)

    def drawEventMap(self):
        dM = self.dictMagnitude
        dO = self.dictOrigin
        if dO == {}:
            err = "Error: No hypocenter data!"
            print >> sys.stderr, err
            return
        #XXX self.figEventMap.canvas.widgetlock.release(toolbar)
        #self.axEventMap = self.fig.add_subplot(111)
        bbox = matplotlib.transforms.Bbox.from_extents(0.08, 0.08, 0.92, 0.92)
        self.axEventMap = self.fig.add_axes(bbox, aspect='equal', adjustable='datalim')
        axEM = self.axEventMap
        #axEM.set_aspect('equal', adjustable="datalim")
        #self.fig.subplots_adjust(bottom=0.07, top=0.95, left=0.07, right=0.98)
        axEM.scatter([dO['Longitude']], [dO['Latitude']], 30,
                                color='red', marker='o')
        errLon, errLat = utlLonLat(dO['Longitude'], dO['Latitude'],
                                   dO['Longitude Error'], dO['Latitude Error'])
        errLon -= dO['Longitude']
        errLat -= dO['Latitude']
        ypos = 0.97
        xpos = 0.03
        axEM.text(xpos, ypos,
                  '%7.3f +/- %0.2fkm\n' % (dO['Longitude'], dO['Longitude Error']) + \
                  '%7.3f +/- %0.2fkm\n' % (dO['Latitude'], dO['Latitude Error']) + \
                  '  %.1fkm +/- %.1fkm' % (dO['Depth'], dO['Depth Error']),
                  va='top', ha='left', family='monospace', transform=axEM.transAxes)
        if 'Standarderror' in dO:
            axEM.text(xpos, ypos, "\n\n\n\n Residual: %.3f s" % \
                      dO['Standarderror'], va='top', ha='left',
                      color=PHASE_COLORS['P'], transform=axEM.transAxes,
                      family='monospace')
        if 'Magnitude' in dM and 'Uncertainty' in dM:
            self.netMagLabel = '\n\n\n\n\n %.2f (Var: %.2f)' % \
                               (dM['Magnitude'], dM['Uncertainty'])
            self.netMagText = axEM.text(xpos, ypos, self.netMagLabel, va='top',
                    ha='left', transform=axEM.transAxes,
                    color=PHASE_COLORS['Mag'], family='monospace')
        errorell = Ellipse(xy=[dO['Longitude'], dO['Latitude']],
                           width=errLon, height=errLat, angle=0, fill=False)
        axEM.add_artist(errorell)
        self.scatterMagIndices = []
        self.scatterMagLon = []
        self.scatterMagLat = []
        for i, dict in enumerate(self.dicts):
            # determine which stations are used in location, set color
            if any([ph + "res" in dict for ph in SEISMIC_PHASES]):
                stationColor = 'black'
            else:
                stationColor = 'gray'
            # plot stations at respective coordinates with names
            axEM.scatter((dict['StaLon'],), (dict['StaLat'],), s=300,
                         marker='v', color='', edgecolor=stationColor)
            axEM.text(dict['StaLon'], dict['StaLat'], '  ' + dict['Station'],
                      color=stationColor, va='top', family='monospace')
            for _i, ph in enumerate(SEISMIC_PHASES):
                if ph + 'res' in dict:
                    res_info = '\n' * (_i + 2) + '%+0.3fs' % dict[ph + 'res']
                    if ph + 'Pol' in dict:
                        res_info += '  %s' % dict[ph + 'Pol']
                    axEM.text(dict['StaLon'], dict['StaLat'], res_info,
                              va='top', family='monospace',
                              color=PHASE_COLORS[ph])
            if 'Mag' in dict:
                self.scatterMagIndices.append(i)
                self.scatterMagLon.append(dict['StaLon'])
                self.scatterMagLat.append(dict['StaLat'])
                label = '\n' * (_i + 3) + \
                        '  %0.2f (%s)' % (dict['Mag'], dict['MagChannel'])
                axEM.text(dict['StaLon'], dict['StaLat'], label, va='top',
                          family='monospace', color=PHASE_COLORS['Mag'])
        if len(self.scatterMagLon) > 0:
            self.scatterMag = axEM.scatter(self.scatterMagLon,
                    self.scatterMagLat, s=150, marker='v', color='',
                    edgecolor='black', picker=10)
                
        axEM.set_xlabel('Longitude')
        axEM.set_ylabel('Latitude')
        time = dO['Time']
        timestr = time.strftime("%Y-%m-%d  %H:%M:%S")
        timestr += ".%02d" % (time.microsecond / 1e4 + 0.5)
        axEM.set_title(timestr)
        #####XXX disabled because it plots the wrong info if the event was
        ##### fetched from seishub
        #####lines = open(PROGRAMS['3dloc']['files']['out']).readlines()
        #####infoEvent = lines[0].rstrip()
        #####infoPicks = ''
        #####for line in lines[1:]:
        #####    infoPicks += line
        #####axEM.text(0.02, 0.95, infoEvent, transform = axEM.transAxes,
        #####                  fontsize = 12, verticalalignment = 'top',
        #####                  family = 'monospace')
        #####axEM.text(0.02, 0.90, infoPicks, transform = axEM.transAxes,
        #####                  fontsize = 10, verticalalignment = 'top',
        #####                  family = 'monospace')
        # save id to disconnect when switching back to stream dislay
        self.eventMapPickEvent = self.canv.mpl_connect('pick_event',
                                                       self.selectMagnitudes)
        try:
            self.scatterMag.set_facecolors(self.eventMapColors)
        except:
            pass

        # make hexbin scatter plot, if located with NLLoc
        # XXX no vital commands should come after this block, as we do not
        # handle exceptions!
        if dO.get('Program') == "NLLoc" and os.path.isfile(PROGRAMS['nlloc']['files']['scatter']):
            cmap = matplotlib.cm.gist_heat_r
            data = readNLLocScatter(PROGRAMS['nlloc']['files']['scatter'],
                                    self.widgets.qPlainTextEdit_stderr)
            axEM.hexbin(data[0], data[1], cmap=cmap, zorder=-1000)

            self.axEventMapInletXY = self.fig.add_axes([0.8, 0.8, 0.16, 0.16])
            axEMiXY = self.axEventMapInletXY
            self.axEventMapInletXZ = self.fig.add_axes([0.8, 0.73, 0.16, 0.06],
                    sharex=axEMiXY)
            self.axEventMapInletZY = self.fig.add_axes([0.73, 0.8, 0.06, 0.16],
                    sharey=axEMiXY)
            axEMiXZ = self.axEventMapInletXZ
            axEMiZY = self.axEventMapInletZY
            
            # z axis in km
            axEMiXY.hexbin(data[0], data[1], cmap=cmap)
            axEMiXZ.hexbin(data[0], data[2]/1000., cmap=cmap)
            axEMiZY.hexbin(data[2]/1000., data[1], cmap=cmap)

            axEMiXZ.invert_yaxis()
            axEMiZY.invert_xaxis()
            axEMiXY.axis("equal")
            
            formatter = FormatStrFormatter("%.3f")
            axEMiXY.xaxis.set_major_formatter(formatter)
            axEMiXY.yaxis.set_major_formatter(formatter)
            
            # only draw very few ticklabels in our tiny subaxes
            for ax in [axEMiXZ.xaxis, axEMiXZ.yaxis,
                       axEMiZY.xaxis, axEMiZY.yaxis]:
                ax.set_major_locator(MaxNLocator(nbins=3))
            
            # hide ticklabels on XY plot
            for ax in [axEMiXY.xaxis, axEMiXY.yaxis]:
                plt.setp(ax.get_ticklabels(), visible=False)

    def delEventMap(self):
        try:
            self.canv.mpl_disconnect(self.eventMapPickEvent)
        except AttributeError:
            pass
        if hasattr(self, "axEventMapInletXY"):
            self.fig.delaxes(self.axEventMapInletXY)
            del self.axEventMapInletXY
        if hasattr(self, "axEventMapInletXZ"):
            self.fig.delaxes(self.axEventMapInletXZ)
            del self.axEventMapInletXZ
        if hasattr(self, "axEventMapInletZY"):
            self.fig.delaxes(self.axEventMapInletZY)
            del self.axEventMapInletZY
        if hasattr(self, "axEventMap"):
            self.fig.delaxes(self.axEventMap)
            del self.axEventMap

    def selectMagnitudes(self, event):
        if not self.widgets.qToolButton_showMap.isChecked():
            return
        if event.artist != self.scatterMag:
            return
        i = self.scatterMagIndices[event.ind[0]]
        j = event.ind[0]
        dict = self.dicts[i]
        dict['MagUse'] = not dict['MagUse']
        if dict['MagUse']:
            self.eventMapColors[j] = (0.,  1.,  0.,  1.)
        else:
            self.eventMapColors[j] = (0.,  0.,  0.,  0.)
        self.scatterMag.set_facecolors(self.eventMapColors)
        self.updateNetworkMag()
        self.canv.draw()
    
    def dicts2hypo71Stations(self):
        """
        Returns the station location information in self.dicts in hypo71
        stations file format as a string. This string can then be written to
        a file.
        """
        fmt = "%6s%02i%05.2fN%03i%05.2fE%4i\n"
        hypo71_string = ""

        for dict in self.dicts:
            sta = dict['Station']
            lon = dict['StaLon']
            lon_deg = int(lon)
            lon_min = (lon - lon_deg) * 60.
            lat = dict['StaLat']
            lat_deg = int(lat)
            lat_min = (lat - lat_deg) * 60.
            # hypo 71 format uses elevation in meters not kilometers
            ele = dict['StaEle'] * 1000
            hypo71_string += fmt % (sta, lat_deg, lat_min, lon_deg, lon_min,
                                    ele)

        return hypo71_string
    
    def dicts2hypo71Phases(self):
        """
        Returns the pick information in self.dicts in hypo71 phase file format
        as a string. This string can then be written to a file.

        Information on the file formats can be found at:
        http://geopubs.wr.usgs.gov/open-file/of02-171/of02-171.pdf p.30

        Quote:
        The traditional USGS phase data input format (not Y2000 compatible)
        Some fields were added after the original HYPO71 phase format
        definition.
        
        Col. Len. Format Data
         1    4  A4       4-letter station site code. Also see col 78.
         5    2  A2       P remark such as "IP". If blank, any P time is
                          ignored.
         7    1  A1       P first motion such as U, D, +, -, C, D.
         8    1  I1       Assigned P weight code.
         9    1  A1       Optional 1-letter station component.
        10   10  5I2      Year, month, day, hour and minute.
        20    5  F5.2     Second of P arrival.
        25    1  1X       Presently unused.
        26    6  6X       Reserved remark field. This field is not copied to
                          output files.
        32    5  F5.2     Second of S arrival. The S time will be used if this
                          field is nonblank.
        37    2  A2, 1X   S remark such as "ES".
        40    1  I1       Assigned weight code for S.
        41    1  A1, 3X   Data source code. This is copied to the archive
                          output.
        45    3  F3.0     Peak-to-peak amplitude in mm on Develocorder viewer
                          screen or paper record.
        48    3  F3.2     Optional period in seconds of amplitude read on the
                          seismogram. If blank, use the standard period from
                          station file.
        51    1  I1       Amplitude magnitude weight code. Same codes as P & S.
        52    3  3X       Amplitude magnitude remark (presently unused).
        55    4  I4       Optional event sequence or ID number. This number may
                          be replaced by an ID number on the terminator line.
        59    4  F4.1     Optional calibration factor to use for amplitude
                          magnitudes. If blank, the standard cal factor from
                          the station file is used.
        63    3  A3       Optional event remark. Certain event remarks are
                          translated into 1-letter codes to save in output.
        66    5  F5.2     Clock correction to be added to both P and S times.
        71    1  A1       Station seismogram remark. Unused except as a label
                          on output.
        72    4  F4.0     Coda duration in seconds.
        76    1  I1       Duration magnitude weight code. Same codes as P & S.
        77    1  1X       Reserved.
        78    1  A1       Optional 5th letter of station site code.
        79    3  A3       Station component code.
        82    2  A2       Station network code.
        84-85 2  A2     2-letter station location code (component extension).
        """

        fmtP = "%4s%1sP%1s%1i %15s"
        fmtS = "%12s%1sS%1s%1i\n"
        hypo71_string = ""

        for st, dict in zip(self.streams, self.dicts):
            sta = dict['Station']
            if 'P' not in dict and 'S' not in dict:
                continue
            if 'P' in dict:
                t = st[0].stats.starttime
                t += dict['P']
                date = t.strftime("%y%m%d%H%M%S")
                date += ".%02d" % (t.microsecond / 1e4 + 0.5)
                if 'POnset' in dict:
                    if dict['POnset'] == 'impulsive':
                        onset = 'I'
                    elif dict['POnset'] == 'emergent':
                        onset = 'E'
                    else: #XXX check for other names correctly!!!
                        onset = '?'
                else:
                    onset = '?'
                if 'PPol' in dict:
                    if dict['PPol'] == "up" or dict['PPol'] == "poorup":
                        polarity = "U"
                    elif dict['PPol'] == "down" or dict['PPol'] == "poordown":
                        polarity = "D"
                    else: #XXX check for other names correctly!!!
                        polarity = "?"
                else:
                    polarity = "?"
                if 'PWeight' in dict:
                    weight = int(dict['PWeight'])
                else:
                    weight = 0
                hypo71_string += fmtP % (sta, onset, polarity, weight, date)
            if 'S' in dict:
                if not 'P' in dict:
                    err = "Warning: Trying to print a Hypo2000 phase file " + \
                          "with an S phase without P phase.\n" + \
                          "This case might not be covered correctly and " + \
                          "could screw our file up!"
                    print >> sys.stderr, err
                t2 = st[0].stats.starttime
                t2 += dict['S']
                # if the S time's absolute minute is higher than that of the
                # P pick, we have to add 60 to the S second count for the
                # hypo 2000 output file
                # +60 %60 is necessary if t.min = 57, t2.min = 2 e.g.
                mindiff = (t2.minute - t.minute + 60) % 60
                abs_sec = t2.second + (mindiff * 60)
                if abs_sec > 99:
                    err = "Warning: S phase seconds are greater than 99 " + \
                          "which is not covered by the hypo phase file " + \
                          "format! Omitting S phase of station %s!" % sta
                    print >> sys.stderr, err
                    hypo71_string += "\n"
                    continue
                date2 = str(abs_sec)
                date2 += ".%02d" % (t2.microsecond / 1e4 + 0.5)
                if 'SOnset' in dict:
                    if dict['SOnset'] == 'impulsive':
                        onset2 = 'I'
                    elif dict['SOnset'] == 'emergent':
                        onset2 = 'E'
                    else: #XXX check for other names correctly!!!
                        onset2 = '?'
                else:
                    onset2 = '?'
                if 'SPol' in dict:
                    if dict['SPol'] == "up" or dict['SPol'] == "poorup":
                        polarity2 = "U"
                    elif dict['SPol'] == "down" or dict['SPol'] == "poordown":
                        polarity2 = "D"
                    else: #XXX check for other names correctly!!!
                        polarity2 = "?"
                else:
                    polarity2 = "?"
                if 'SWeight' in dict:
                    weight2 = int(dict['SWeight'])
                else:
                    weight2 = 0
                hypo71_string += fmtS % (date2, onset2, polarity2, weight2)
            else:
                hypo71_string += "\n"

        return hypo71_string

    def dicts2XML(self):
        """
        Returns information of all dictionaries as xml file (type string)
        """
        xml =  lxml.etree.Element("event")
        Sub(Sub(xml, "event_id"), "value").text = self.dictEvent['xmlEventID']
        event_type = Sub(xml, "event_type")
        Sub(event_type, "value").text = "manual"

        # if the sysop checkbox is checked, we set the account in the xml
        # to sysop (and also use sysop as the seishub user)
        if self.widgets.qCheckBox_sysop.isChecked():
            Sub(event_type, "account").text = "sysop"
        else:
            Sub(event_type, "account").text = self.server['User']
        
        Sub(event_type, "user").text = self.username

        Sub(event_type, "public").text = "%s" % \
                self.widgets.qCheckBox_publishEvent.isChecked()
        
        # XXX standard values for unset keys!!!???!!!???
        epidists = []
        # go through all stream-dictionaries and look for picks
        for st, dict in zip(self.streams, self.dicts):
            # write P Pick info
            if 'P' in dict:
                pick = Sub(xml, "pick")
                wave = Sub(pick, "waveform")
                wave.set("networkCode", st[0].stats.network) 
                wave.set("stationCode", st[0].stats.station) 
                wave.set("channelCode", st[0].stats.channel) 
                wave.set("locationCode", st[0].stats.location) 
                date = Sub(pick, "time")
                # prepare time of pick
                picktime = st[0].stats.starttime
                picktime += dict['P']
                Sub(date, "value").text = picktime.isoformat() # + '.%06i' % picktime.microsecond)
                if 'PErr1' in dict and 'PErr2' in dict:
                    temp = dict['PErr2'] - dict['PErr1']
                    Sub(date, "uncertainty").text = str(temp)
                else:
                    Sub(date, "uncertainty")
                Sub(pick, "phaseHint").text = "P"
                phase_compu = ""
                if 'POnset' in dict:
                    Sub(pick, "onset").text = dict['POnset']
                    if dict['POnset'] == "impulsive":
                        phase_compu += "I"
                    elif dict['POnset'] == "emergent":
                        phase_compu += "E"
                else:
                    Sub(pick, "onset")
                    phase_compu += "?"
                phase_compu += "P"
                if 'PPol' in dict:
                    Sub(pick, "polarity").text = dict['PPol']
                    if dict['PPol'] == 'up':
                        phase_compu += "U"
                    elif dict['PPol'] == 'poorup':
                        phase_compu += "+"
                    elif dict['PPol'] == 'down':
                        phase_compu += "D"
                    elif dict['PPol'] == 'poordown':
                        phase_compu += "-"
                else:
                    Sub(pick, "polarity")
                    phase_compu += "?"
                if 'PWeight' in dict:
                    Sub(pick, "weight").text = '%i' % dict['PWeight']
                    phase_compu += "%1i" % dict['PWeight']
                else:
                    Sub(pick, "weight")
                    phase_compu += "?"
                Sub(Sub(pick, "min_amp"), "value") #XXX what is min_amp???
                
                if 'Psynth' in dict:
                    Sub(pick, "phase_compu").text = phase_compu
                    Sub(Sub(pick, "phase_res"), "value").text = str(dict['Pres'])
                    if 'PsynthWeight' in dict:
                        Sub(Sub(pick, "phase_weight"), "value").text = \
                                str(dict['PsynthWeight'])
                    else:
                        Sub(Sub(pick, "phase_weight"), "value")
                    Sub(Sub(pick, "phase_delay"), "value")
                    Sub(Sub(pick, "azimuth"), "value").text = str(dict['PAzim'])
                    Sub(Sub(pick, "incident"), "value").text = str(dict['PInci'])
                    Sub(Sub(pick, "epi_dist"), "value").text = \
                            str(dict['distEpi'])
                    Sub(Sub(pick, "hyp_dist"), "value").text = \
                            str(dict['distHypo'])
        
            # write S Pick info
            if 'S' in dict:
                axind = dict['Saxind']
                pick = Sub(xml, "pick")
                wave = Sub(pick, "waveform")
                wave.set("networkCode", st[axind].stats.network) 
                wave.set("stationCode", st[axind].stats.station) 
                wave.set("channelCode", st[axind].stats.channel) 
                wave.set("locationCode", st[axind].stats.location) 
                date = Sub(pick, "time")
                # prepare time of pick
                picktime = st[0].stats.starttime
                picktime += dict['S']
                Sub(date, "value").text = picktime.isoformat() # + '.%06i' % picktime.microsecond)
                if 'SErr1' in dict and 'SErr2' in dict:
                    temp = dict['SErr2'] - dict['SErr1']
                    Sub(date, "uncertainty").text = str(temp)
                else:
                    Sub(date, "uncertainty")
                Sub(pick, "phaseHint").text = "S"
                phase_compu = ""
                if 'SOnset' in dict:
                    Sub(pick, "onset").text = dict['SOnset']
                    if dict['SOnset'] == "impulsive":
                        phase_compu += "I"
                    elif dict['SOnset'] == "emergent":
                        phase_compu += "E"
                else:
                    Sub(pick, "onset")
                    phase_compu += "?"
                phase_compu += "S"
                if 'SPol' in dict:
                    Sub(pick, "polarity").text = dict['SPol']
                    if dict['SPol'] == 'up':
                        phase_compu += "U"
                    elif dict['SPol'] == 'poorup':
                        phase_compu += "+"
                    elif dict['SPol'] == 'down':
                        phase_compu += "D"
                    elif dict['SPol'] == 'poordown':
                        phase_compu += "-"
                else:
                    Sub(pick, "polarity")
                    phase_compu += "?"
                if 'SWeight' in dict:
                    Sub(pick, "weight").text = '%i' % dict['SWeight']
                    phase_compu += "%1i" % dict['SWeight']
                else:
                    Sub(pick, "weight")
                    phase_compu += "?"
                Sub(Sub(pick, "min_amp"), "value") #XXX what is min_amp???
                
                if 'Ssynth' in dict:
                    Sub(pick, "phase_compu").text = phase_compu
                    Sub(Sub(pick, "phase_res"), "value").text = str(dict['Sres'])
                    if 'SsynthWeight' in dict:
                        Sub(Sub(pick, "phase_weight"), "value").text = \
                                str(dict['SsynthWeight'])
                    else:
                        Sub(Sub(pick, "phase_weight"), "value")
                    Sub(Sub(pick, "phase_delay"), "value")
                    Sub(Sub(pick, "azimuth"), "value").text = str(dict['SAzim'])
                    Sub(Sub(pick, "incident"), "value").text = str(dict['SInci'])
                    Sub(Sub(pick, "epi_dist"), "value").text = \
                            str(dict['distEpi'])
                    Sub(Sub(pick, "hyp_dist"), "value").text = \
                            str(dict['distHypo'])

        #origin output
        dO = self.dictOrigin
        #we always have one key 'Program', if len > 1 we have real information
        #its possible that we have set the 'Program' key but afterwards
        #the actual program run does not fill our dictionary...
        if len(dO) > 1:
            origin = Sub(xml, "origin")
            Sub(origin, "program").text = dO['Program']
            date = Sub(origin, "time")
            Sub(date, "value").text = dO['Time'].isoformat() # + '.%03i' % self.dictOrigin['Time'].microsecond
            Sub(date, "uncertainty")
            lat = Sub(origin, "latitude")
            Sub(lat, "value").text = str(dO['Latitude'])
            Sub(lat, "uncertainty").text = str(dO['Latitude Error']) #XXX Lat Error in km!!
            lon = Sub(origin, "longitude")
            Sub(lon, "value").text = str(dO['Longitude'])
            Sub(lon, "uncertainty").text = str(dO['Longitude Error']) #XXX Lon Error in km!!
            depth = Sub(origin, "depth")
            Sub(depth, "value").text = str(dO['Depth'])
            Sub(depth, "uncertainty").text = str(dO['Depth Error'])
            if 'Depth Type' in dO:
                Sub(origin, "depth_type").text = str(dO['Depth Type'])
            else:
                Sub(origin, "depth_type")
            if 'Earth Model' in dO:
                Sub(origin, "earth_mod").text = dO['Earth Model']
            else:
                Sub(origin, "earth_mod")
            if dO['Program'] == "hyp2000":
                uncertainty = Sub(origin, "originUncertainty")
                Sub(uncertainty, "preferredDescription").text = "uncertainty ellipse"
                Sub(uncertainty, "horizontalUncertainty")
                Sub(uncertainty, "minHorizontalUncertainty")
                Sub(uncertainty, "maxHorizontalUncertainty")
                Sub(uncertainty, "azimuthMaxHorizontalUncertainty")
            else:
                Sub(origin, "originUncertainty")
            quality = Sub(origin, "originQuality")
            Sub(quality, "P_usedPhaseCount").text = '%i' % dO['used P Count']
            Sub(quality, "S_usedPhaseCount").text = '%i' % dO['used S Count']
            Sub(quality, "usedPhaseCount").text = '%i' % (dO['used P Count'] + dO['used S Count'])
            Sub(quality, "usedStationCount").text = '%i' % dO['used Station Count']
            Sub(quality, "associatedPhaseCount").text = '%i' % (dO['used P Count'] + dO['used S Count'])
            Sub(quality, "associatedStationCount").text = '%i' % len(self.dicts)
            Sub(quality, "depthPhaseCount").text = "0"
            Sub(quality, "standardError").text = str(dO['Standarderror'])
            Sub(quality, "azimuthalGap").text = str(dO['Azimuthal Gap'])
            Sub(quality, "groundTruthLevel")
            Sub(quality, "minimumDistance").text = str(dO['Minimum Distance'])
            Sub(quality, "maximumDistance").text = str(dO['Maximum Distance'])
            Sub(quality, "medianDistance").text = str(dO['Median Distance'])
        
        #magnitude output
        dM = self.dictMagnitude
        #we always have one key 'Program', if len > 1 we have real information
        #its possible that we have set the 'Program' key but afterwards
        #the actual program run does not fill our dictionary...
        if len(dM) > 1:
            magnitude = Sub(xml, "magnitude")
            Sub(magnitude, "program").text = dM['Program']
            mag = Sub(magnitude, "mag")
            if np.isnan(dM['Magnitude']):
                Sub(mag, "value")
                Sub(mag, "uncertainty")
            else:
                Sub(mag, "value").text = str(dM['Magnitude'])
                Sub(mag, "uncertainty").text = str(dM['Uncertainty'])
            Sub(magnitude, "type").text = "Ml"
            Sub(magnitude, "stationCount").text = '%i' % dM['Station Count']
            for dict in self.dicts:
                if 'Mag' in dict:
                    stationMagnitude = Sub(xml, "stationMagnitude")
                    mag = Sub(stationMagnitude, 'mag')
                    Sub(mag, 'value').text = str(dict['Mag'])
                    Sub(mag, 'uncertainty').text
                    Sub(stationMagnitude, 'station').text = str(dict['Station'])
                    if dict['MagUse']:
                        Sub(stationMagnitude, 'weight').text = str(1. / dM['Station Count'])
                    else:
                        Sub(stationMagnitude, 'weight').text = "0"
                    Sub(stationMagnitude, 'channels').text = str(dict['MagChannel'])
        
        #focal mechanism output
        dF = self.dictFocalMechanism
        #we always have one key 'Program', if len > 1 we have real information
        #its possible that we have set the 'Program' key but afterwards
        #the actual program run does not fill our dictionary...
        if len(dF) > 1:
            focmec = Sub(xml, "focalMechanism")
            Sub(focmec, "program").text = dF['Program']
            nodplanes = Sub(focmec, "nodalPlanes")
            nodplanes.set("preferredPlane", "1")
            nodplane1 = Sub(nodplanes, "nodalPlane1")
            strike = Sub(nodplane1, "strike")
            Sub(strike, "value").text = str(dF['Strike'])
            Sub(strike, "uncertainty")
            dip = Sub(nodplane1, "dip")
            Sub(dip, "value").text = str(dF['Dip'])
            Sub(dip, "uncertainty")
            rake = Sub(nodplane1, "rake")
            Sub(rake, "value").text = str(dF['Rake'])
            Sub(rake, "uncertainty")
            Sub(focmec, "stationPolarityCount").text = "%i" % \
                    dF['Station Polarity Count']
            Sub(focmec, "stationPolarityErrorCount").text = "%i" % dF['Errors']
            Sub(focmec, "possibleSolutionCount").text = "%i" % \
                    dF['Possible Solution Count']

        return lxml.etree.tostring(xml, pretty_print=True, xml_declaration=True)
    
    def setXMLEventID(self):
        #XXX is problematic if two people make a location at the same second!
        # then one event is overwritten with the other during submission.
        self.dictEvent['xmlEventID'] = UTCDateTime().strftime('%Y%m%d%H%M%S')

    def uploadSeishub(self):
        """
        Upload xml file to SeisHub
        """
        # check, if the event should be uploaded as sysop. in this case we use
        # the sysop client instance for the upload (and also set
        # user_account in the xml to "sysop").
        # the correctness of the sysop password is tested when checking the
        # sysop box and entering the password immediately.
        if self.widgets.qCheckBox_sysop.isChecked():
            userid = "sysop"
            client = self.client_sysop
        else:
            userid = self.server['User']
            client = self.client

        # if we did no location at all, and only picks would be saved the
        # EventID ist still not set, so we have to do this now.
        if 'xmlEventID' not in self.dictEvent:
            self.setXMLEventID()
        name = "obspyck_%s" % (self.dictEvent['xmlEventID']) #XXX id of the file
        # create XML and also save in temporary directory for inspection purposes
        print "creating xml..."
        data = self.dicts2XML()
        tmpfile = os.path.join(self.tmp_dir, name + ".xml")
        print "writing xml as %s (for debugging purposes only!)" % tmpfile
        open(tmpfile, "wt").write(data)

        headers = {}
        headers["Host"] = "localhost"
        headers["User-Agent"] = "obspyck"
        headers["Content-type"] = "text/xml; charset=\"UTF-8\""
        headers["Content-length"] = "%d" % len(data)
        code, message = client.event.putResource(name, xml_string=data,
                                                 headers=headers)
        msg = "Account: %s" % userid
        msg += "\nUser: %s" % self.username
        msg += "\nName: %s" % name
        msg += "\nServer: %s" % self.server['Server']
        msg += "\nResponse: %s %s" % (code, message)
        print msg

    def deleteEventInSeishub(self, resource_name):
        """
        Delete xml file from SeisHub.
        (Move to SeisHubs trash folder if this option is activated)
        """
        # check, if the event should be deleted as sysop. in this case we
        # use the sysop client instance for the DELETE request.
        # sysop may delete resources from any user.
        # at the moment deleted resources go to SeisHubs trash folder (and can
        # easily be resubmitted using the http interface).
        # the correctness of the sysop password is tested when checking the
        # sysop box and entering the password immediately.
        if self.widgets.qCheckBox_sysop.isChecked():
            userid = "sysop"
            client = self.client_sysop
        else:
            userid = self.server['User']
            client = self.client
        
        headers = {}
        headers["Host"] = "localhost"
        headers["User-Agent"] = "obspyck"
        code, message = client.event.deleteResource(str(resource_name),
                                                    headers=headers)
        msg = "Deleting Event!"
        msg += "\nAccount: %s" % userid
        msg += "\nUser: %s" % self.username
        msg += "\nName: %s" % resource_name
        msg += "\nServer: %s" % self.server['Server']
        msg += "\nResponse: %s %s" % (code, message)
        print msg
    
    def clearDictionaries(self):
        print "Clearing previous data."
        dont_delete = ['Station', 'StaLat', 'StaLon', 'StaEle',
                       'pazZ', 'pazN', 'pazE']
        for dict in self.dicts:
            for key in dict.keys():
                if not key in dont_delete:
                    del dict[key]
            dict['MagUse'] = True
        # XXX delegate all resetting to methods like self.clearOriginMagnitudeDictionaries() !!!
        # XXX but caution this can easily change behavior of obspyck!!
        self.dictOrigin = {}
        self.dictMagnitude = {}
        self.clearFocmecDictionary()
        self.dictEvent = {}

    def clearOriginMagnitudeDictionaries(self):
        print "Clearing previous origin and magnitude data."
        dont_delete = ['Station', 'StaLat', 'StaLon', 'StaEle', 'pazZ', 'pazN',
                       'pazE', 'P', 'PErr1', 'PErr2', 'POnset', 'PPol',
                       'PWeight', 'S', 'SErr1', 'SErr2', 'SOnset', 'SPol',
                       'SWeight', 'Saxind',
                       #dont delete the manually picked maxima/minima
                       'MagMin1', 'MagMin1T', 'MagMax1', 'MagMax1T',
                       'MagMin2', 'MagMin2T', 'MagMax2', 'MagMax2T',]
        # we need to delete all station magnitude information from all dicts
        for dict in self.dicts:
            for key in dict.keys():
                if key not in dont_delete:
                    del dict[key]
            dict['MagUse'] = True
        self.dictOrigin = {}
        self.dictMagnitude = {}
        self.dictEvent = {}
        if 'xmlEventID' in self.dictEvent:
            del self.dictEvent['xmlEventID']

    def clearFocmecDictionary(self):
        print "Clearing previous focal mechanism data."
        self.dictFocalMechanism = {}
        self.focMechList = []
        self.focMechCurrent = None
        self.focMechCount = None

    def drawAllItems(self):
        keys_line = (phase_type + suffix \
                     for phase_type in SEISMIC_PHASES \
                     for suffix in ('', 'Err1', 'Err2', 'synth'))
        keys_label = (phase_type + suffix \
                      for phase_type in SEISMIC_PHASES \
                      for suffix in ('', 'synth'))
        for key in keys_line:
            self.drawLine(key)
        for key in keys_label:
            self.drawLabel(key)
        for key in ('MagMin1', 'MagMax1', 'MagMin2', 'MagMax2'):
            self.drawMagMarker(key)
    
    def delAllItems(self):
        keys_line = (phase_type + suffix \
                     for phase_type in SEISMIC_PHASES \
                     for suffix in ('', 'Err1', 'Err2', 'synth'))
        keys_label = (phase_type + suffix \
                      for phase_type in SEISMIC_PHASES \
                      for suffix in ('', 'synth'))
        for key in keys_line:
            self.delLine(key)
        for key in keys_label:
            self.delLabel(key)
        for key in ('MagMin1', 'MagMax1', 'MagMin2', 'MagMax2'):
            self.delMagMarker(key)

    def updateAllItems(self):
        self.delAllItems()
        self.drawAllItems()

    def getEventFromSeishub(self, resource_name):
        """
        Fetch a Resource XML from Seishub
        """
        resource_xml = self.client.event.getXMLResource(resource_name)
        if resource_xml.xpath(u".//event_type/account"):
            account = resource_xml.xpath(u".//event_type/account")[0].text
        else:
            account = None
        if resource_xml.xpath(u".//event_type/user"):
            user = resource_xml.xpath(u".//event_type/user")[0].text
        else:
            user = None

        #analyze picks:
        for pick in resource_xml.xpath(u".//pick"):
            # attributes
            id = pick.find("waveform").attrib
            network = id["networkCode"]
            station = id["stationCode"]
            location = id["locationCode"]
            channel = id['channelCode']
            streamnum = None
            # search for streamnumber corresponding to pick
            for i, dict in enumerate(self.dicts):
                if station.strip() != dict['Station']:
                    continue
                else:
                    streamnum = i
                    break
            if streamnum is None:
                err = "Warning: Did not find matching stream for pick " + \
                      "data with station id: \"%s\"" % station.strip()
                print >> sys.stderr, err
                continue
            # values
            time = pick.xpath(".//time/value")[0].text
            uncertainty = pick.xpath(".//time/uncertainty")[0].text
            try:
                onset = pick.xpath(".//onset")[0].text
            except:
                onset = None
            try:
                polarity = pick.xpath(".//polarity")[0].text
            except:
                polarity = None
            try:
                weight = pick.xpath(".//weight")[0].text
            except:
                weight = None
            try:
                phase_res = pick.xpath(".//phase_res/value")[0].text
            except:
                phase_res = None
            try:
                phase_weight = pick.xpath(".//phase_res/weight")[0].text
            except:
                phase_weight = None
            try:
                azimuth = pick.xpath(".//azimuth/value")[0].text
            except:
                azimuth = None
            try:
                incident = pick.xpath(".//incident/value")[0].text
            except:
                incident = None
            try:
                epi_dist = pick.xpath(".//epi_dist/value")[0].text
            except:
                epi_dist = None
            try:
                hyp_dist = pick.xpath(".//hyp_dist/value")[0].text
            except:
                hyp_dist = None
            # convert UTC time to seconds after stream starttime
            time = UTCDateTime(time)
            time -= self.streams[streamnum][0].stats.starttime
            # map uncertainty in seconds to error picks in seconds
            if uncertainty:
                uncertainty = float(uncertainty)
                uncertainty /= 2.
            # assign to dictionary
            dict = self.dicts[streamnum]
            if pick.xpath(".//phaseHint")[0].text == "P":
                dict['P'] = time
                if uncertainty:
                    dict['PErr1'] = time - uncertainty
                    dict['PErr2'] = time + uncertainty
                if onset:
                    dict['POnset'] = onset
                if polarity:
                    dict['PPol'] = polarity
                if weight:
                    dict['PWeight'] = int(weight)
                if phase_res:
                    # residual is defined as P-Psynth by NLLOC and 3dloc!
                    # XXX does this also hold for hyp2000???
                    dict['Psynth'] = time - float(phase_res)
                    dict['Pres'] = float(phase_res)
                # hypo2000 uses this weight internally during the inversion
                # this is not the same as the weight assigned during picking
                if phase_weight:
                    dict['PsynthWeight'] = phase_weight
                if azimuth:
                    dict['PAzim'] = float(azimuth)
                if incident:
                    dict['PInci'] = float(incident)
            if pick.xpath(".//phaseHint")[0].text == "S":
                dict['S'] = time
                # XXX maybe dangerous to check last character:
                if channel.endswith('N'):
                    dict['Saxind'] = 1
                if channel.endswith('E'):
                    dict['Saxind'] = 2
                if uncertainty:
                    dict['SErr1'] = time - uncertainty
                    dict['SErr2'] = time + uncertainty
                if onset:
                    dict['SOnset'] = onset
                if polarity:
                    dict['SPol'] = polarity
                if weight:
                    dict['SWeight'] = int(weight)
                if phase_res:
                    # residual is defined as S-Ssynth by NLLOC and 3dloc!
                    # XXX does this also hold for hyp2000???
                    dict['Ssynth'] = time - float(phase_res)
                    dict['Sres'] = float(phase_res)
                # hypo2000 uses this weight internally during the inversion
                # this is not the same as the weight assigned during picking
                if phase_weight:
                    dict['SsynthWeight'] = phase_weight
                if azimuth:
                    dict['SAzim'] = float(azimuth)
                if incident:
                    dict['SInci'] = float(incident)
            if epi_dist:
                dict['distEpi'] = float(epi_dist)
            if hyp_dist:
                dict['distHypo'] = float(hyp_dist)

        #analyze origin:
        dO = self.dictOrigin
        try:
            origin = resource_xml.xpath(u".//origin")[0]
            try:
                dO['Program'] = origin.xpath(".//program")[0].text
            except:
                pass
            try:
                dO['Time'] = UTCDateTime(origin.xpath(".//time/value")[0].text)
            except:
                pass
            try:
                dO['Latitude'] = float(origin.xpath(".//latitude/value")[0].text)
            except:
                pass
            try:
                dO['Longitude'] = float(origin.xpath(".//longitude/value")[0].text)
            except:
                pass
            try:
                dO['Longitude Error'] = float(origin.xpath(".//longitude/uncertainty")[0].text)
            except:
                pass
            try:
                dO['Latitude Error'] = float(origin.xpath(".//latitude/uncertainty")[0].text)
            except:
                pass
            try:
                dO['Depth'] = float(origin.xpath(".//depth/value")[0].text)
            except:
                pass
            try:
                dO['Depth Error'] = float(origin.xpath(".//depth/uncertainty")[0].text)
            except:
                pass
            try:
                dO['Depth Type'] = origin.xpath(".//depth_type")[0].text
            except:
                pass
            try:
                dO['Earth Model'] = origin.xpath(".//earth_mod")[0].text
            except:
                pass
            try:
                dO['used P Count'] = int(origin.xpath(".//originQuality/P_usedPhaseCount")[0].text)
            except:
                pass
            try:
                dO['used S Count'] = int(origin.xpath(".//originQuality/S_usedPhaseCount")[0].text)
            except:
                pass
            try:
                dO['used Station Count'] = int(origin.xpath(".//originQuality/usedStationCount")[0].text)
            except:
                pass
            try:
                dO['Standarderror'] = float(origin.xpath(".//originQuality/standardError")[0].text)
            except:
                pass
            try:
                dO['Azimuthal Gap'] = float(origin.xpath(".//originQuality/azimuthalGap")[0].text)
            except:
                pass
            try:
                dO['Minimum Distance'] = float(origin.xpath(".//originQuality/minimumDistance")[0].text)
            except:
                pass
            try:
                dO['Maximum Distance'] = float(origin.xpath(".//originQuality/maximumDistance")[0].text)
            except:
                pass
            try:
                dO['Median Distance'] = float(origin.xpath(".//originQuality/medianDistance")[0].text)
            except:
                pass
        except:
            pass

        #analyze magnitude:
        dM = self.dictMagnitude
        try:
            magnitude = resource_xml.xpath(u".//magnitude")[0]
            try:
                dM['Program'] = magnitude.xpath(".//program")[0].text
            except:
                pass
            try:
                dM['Magnitude'] = float(magnitude.xpath(".//mag/value")[0].text)
                self.netMagLabel = '\n\n\n\n\n %.2f (Var: %.2f)' % \
                        (dM['Magnitude'], dM['Uncertainty'])
            except:
                pass
            try:
                dM['Uncertainty'] = float(magnitude.xpath(".//mag/uncertainty")[0].text)
            except:
                pass
            try:
                dM['Station Count'] = int(magnitude.xpath(".//stationCount")[0].text)
            except:
                pass
        except:
            pass

        #analyze stationmagnitudes:
        for stamag in resource_xml.xpath(u".//stationMagnitude"):
            station = stamag.xpath(".//station")[0].text
            streamnum = None
            # search for streamnumber corresponding to pick
            for i, dict in enumerate(self.dicts):
                if station.strip() != dict['Station']:
                    continue
                else:
                    streamnum = i
                    break
            if streamnum is None:
                err = "Warning: Did not find matching stream for station " + \
                      "magnitude data with id: \"%s\"" % station.strip()
                print >> sys.stderr, err
                continue
            # values
            mag = float(stamag.xpath(".//mag/value")[0].text)
            mag_channel = stamag.xpath(".//channels")[0].text
            mag_weight = float(stamag.xpath(".//weight")[0].text)
            if mag_weight == 0:
                mag_use = False
            else:
                mag_use = True
            # assign to dictionary
            dict = self.dicts[streamnum]
            dict['Mag'] = mag
            dict['MagUse'] = mag_use
            dict['MagChannel'] = mag_channel
        
        #analyze focal mechanism:
        dF = self.dictFocalMechanism
        try:
            focmec = resource_xml.xpath(u".//focalMechanism")[0]
            try:
                dF['Program'] = focmec.xpath(".//program")[0].text
            except:
                pass
            try:
                strike = focmec.xpath(".//nodalPlanes/nodalPlane1/strike/value")[0].text
                dF['Strike'] = float(strike)
                self.focMechCount = 1
                self.focMechCurrent = 0
            except:
                pass
            try:
                dip = focmec.xpath(".//nodalPlanes/nodalPlane1/dip/value")[0].text
                dF['Dip'] = float(dip)
            except:
                pass
            try:
                rake = focmec.xpath(".//nodalPlanes/nodalPlane1/rake/value")[0].text
                dF['Rake'] = float(rake)
            except:
                pass
            try:
                staPolCount = focmec.xpath(".//stationPolarityCount")[0].text
                dF['Station Polarity Count'] = int(staPolCount)
            except:
                pass
            try:
                staPolErrCount = focmec.xpath(".//stationPolarityErrorCount")[0].text
                dF['Errors'] = int(staPolErrCount)
            except:
                pass
        except:
            pass
        print "Fetched event %i of %i: %s (account: %s, user: %s)"% \
              (self.seishubEventCurrent + 1, self.seishubEventCount,
               resource_name, account, user)

    def updateEventListFromSeishub(self, starttime, endtime):
        """
        Searches for events in the database and stores a list of resource
        names. All events with at least one pick set in between start- and
        endtime are returned.

        :param starttime: Start datetime as UTCDateTime
        :param endtime: End datetime as UTCDateTime
        """
        self.checkForSysopEventDuplicates(self.streams[0][0].stats.starttime,
                                          self.streams[0][0].stats.endtime)

        events = self.client.event.getList(min_last_pick=starttime,
                                           max_first_pick=endtime)
        self.seishubEventList = events
        self.seishubEventCount = len(events)
        # we set the current event-pointer to the last list element, because we
        # iterate the counter immediately when fetching the first event...
        self.seishubEventCurrent = len(events) - 1
        msg = "%i events are available from Seishub" % len(events)
        for event in events:
            resource_name = event.get('resource_name')
            account = event.get('account')
            user = event.get('user')
            msg += "\n  - %s (account: %s, user: %s)" % (resource_name,
                                                         account, user)
        print msg

    def checkForSysopEventDuplicates(self, starttime, endtime):
        """
        checks if there is more than one sysop event with picks in between
        starttime and endtime. if that is the case, a warning is issued.
        the user should then resolve this conflict by deleting events until
        only one instance remains.
        at the moment this check is conducted for the current timewindow when
        submitting a sysop event.
        """
        events = self.client.event.getList(min_last_pick=starttime,
                                                max_first_pick=endtime)
        sysop_events = [str(event.get('resource_name')) for event in events \
                        if event.get('account', None) == "sysop"]

        # if there is a possible duplicate, pop up a warning window and print a
        # warning in the GUI error textview:
        if len(sysop_events) > 1:
            err = "ObsPyck found more than one sysop event with picks in " + \
                  "the current time window! Please check if these are " + \
                  "duplicate events and delete old resources."
            errlist = "\n".join(sysop_events)
            print >> sys.stderr, err
            print >> sys.stderr, errlist
            qMessageBox = QtGui.QMessageBox()
            qMessageBox.setWindowIcon(QtGui.QIcon(QtGui.QPixmap("obspyck.gif")))
            qMessageBox.setIcon(QtGui.QMessageBox.Critical)
            qMessageBox.setWindowTitle("Possible Duplicate SysOp Event!")
            qMessageBox.setText(err)
            qMessageBox.setInformativeText(errlist)
            qMessageBox.setStandardButtons(QtGui.QMessageBox.Ok)
            qMessageBox.exec_()


def main():
    """
    Gets executed when the program starts.
    """
    usage = "\n * SeisHub:\n    " + \
            "%prog -t 2010-08-01T12:00:00 -d 30 -i BW.R*..EH*,BW.BGLD..EH*\n" + \
            " * ArcLink:\n    " + \
            "%prog -t 2010-08-01T12:00:00 -d 30 --arclink-ids GE.APE..BH*,GE.IMMV..BH*\n" + \
            " * Fissures:\n    " + \
            "%prog -t 2010-08-01T12:00:00 -d 30 --fissures-ids GR.GRA1..BH*,DK.BSD..BH*\n" + \
            " * combination of clients:\n    " + \
            "%prog -t 2010-08-01T12:00:00 -d 30 -i BW.R*..EH* --arclink-ids GE.APE..BH* --fissures-ids GR.GRA1..BH*" + \
            "\n\nGet all available options with: %prog -h"
    parser = optparse.OptionParser(usage)
    for opt_args, opt_kwargs in COMMANDLINE_OPTIONS:
        parser.add_option(*opt_args, **opt_kwargs)
    (options, args) = parser.parse_args()
    # For keybindings option, just print them and exit.
    if options.keybindings:
        for key, value in KEYS.iteritems():
            print "%s: \"%s\"" % (key, value)
        return
    # check for necessary options
    if not any([getattr(parser.values, parser.get_option(opt).dest) \
                for opt in ("-i", "--arclink-ids", "--fissures-ids")]) \
       or not all([getattr(parser.values, parser.get_option(opt).dest) \
                   for opt in ('-d', '-t')]):
        parser.print_usage()
        return
    check_keybinding_conflicts(KEYS)
    # XXX changed this again, we dont want qt to handle keys
    # XXX obspyck = ObsPyck(client, streams, options, qkeys)
    #qkeys = map_qKeys(KEYS)
    # XXX wasn't working as expected
    #if options.debug:
    #    import IPython.Shell
    #    IPython.Shell.IPShellEmbed(['-pdb'],
    #            banner='Entering IPython.  Press Ctrl-D to exit.',
    #            exit_msg='Leaving Interpreter, back to program.')()
    (client, streams) = fetch_waveforms_metadata(options)
    # Create the GUI application
    qApp = QtGui.QApplication(sys.argv)
    #qApp = MyApp(sys.argv)
    #qApp.installEventFilter(SomeFilter()) #ev_filt = Qt.EventFilter(qApp)
    # XXX changed this again, we dont want qt to handle keys
    # XXX obspyck = ObsPyck(client, streams, options, qkeys)
    obspyck = ObsPyck(client, streams, options, KEYS)
    qApp.connect(qApp, QtCore.SIGNAL("aboutToQuit()"), obspyck.cleanup)
    #obspyck.installEventFilter(SomeFilter()) #ev_filt = Qt.EventFilter(qApp)
    # Start maximized.
    os._exit(qApp.exec_())

#
#class SomeFilter(QtCore.QObject):
#    def eventFilter(self, obj, ev):
#        print("Event filtering ok")
#        return True
#
#class EventFilter(QtCore.QObject)
#    def eventFilter(obj, ev):
#     if (object == target && event->type() == QEvent::KeyPress) {
#         QKeyEvent *keyEvent = static_cast<QKeyEvent *>(event);
#         if (keyEvent->key() == Qt::Key_Tab) {
#             // Special tab handling
#             return true;
#         } else
#             return false;
#     }
#     return false;
# }

#class MyApp(QtGui.QApplication):
#    def eventFilter(self, obj, ev):
#        print "no filtering but could..."
#        return False

if __name__ == "__main__":
    main()
